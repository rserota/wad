{"version":3,"sources":["webpack://Wad/webpack/universalModuleDefinition","webpack://Wad/webpack/bootstrap","webpack://Wad/./node_modules/tunajs/tuna.js","webpack://Wad/(webpack)/buildin/harmony-module.js","webpack://Wad/./src/sound_iterator.js","webpack://Wad/./src/wad.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,QAAQ,KAA6B;AACrC;AACA,KAAK,UAAU,IAA4B;AAC3C;AACA,KAAK,MAAM,EAEN;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA,6DAA6D;AAC7D;AACA,yDAAyD;AACzD;AACA,yDAAyD;AACzD;AACA,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uDAAuD;AACvD;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,+BAA+B,WAAW;AAC1C,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACtuED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,6BAA6B,kDAAkD;AAC/E;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACa;;AAEb,mCAAmC,mFAAmF,wCAAwC,EAAE,OAAO,8BAA8B,EAAE;;AAEvM,iDAAiD,2CAA2C,0DAA0D,EAAE;;AAExJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;AAEnB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,EAAE;;AAEP,4CAA4C;;AAE5C;AACA;AACA,mBAAmB;;AAEnB,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACc,4E;;;;;;;;;;;;AClNf;AAAA;AAAA;AAAA;AAA0B;AACkB;;;AAG5C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,G;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF,oBAAoB,mDAAmD;AACvE,OAAO,2DAA2D;;;AAGlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,sBAAsB,mBAAmB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA,4BAA4B,+BAA+B;AAC3D,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,+BAA+B;AAC5D,sCAAsC,iBAAiB;AACvD,wHAAwH;AACxH;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA,GAAG,yBAAyB,0DAA0D,EAAE,EAAE;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA,oCAAoC,0BAA0B;;AAE9D,oCAAoC,8BAA8B;;AAElE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D,+CAA+C;AAC/C;AACA,sBAAsB;AACtB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+BAA+B,2DAA2D;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,aAAa,6CAAI;AACjB,iBAAiB,6CAAI;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC;AACnC,uCAAuC,iCAAiC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,qBAAqB,cAAc;AACnC,sBAAsB,0BAA0B;AAChD,SAAS,kCAAkC;AAC3C;AACA,wBAAwB,2DAA2D;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,8BAA8B;;AAErD;AACA;AACA;;;AAGA;;AAEA;;AAEA,6CAA6C,sBAAsB;AACnE;;AAEA;AACA,wBAAwB,+BAA+B;;AAEvD;AACA,wBAAwB,+BAA+B;AACvD;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;;AAEA;;;AAGA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,Q;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,sBAAsB;AACtB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,uBAAuB;AACvD;;AAEA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,eAAe,UAAU;AACzB;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;;AAEhD;AACA,sBAAsB,0BAA0B;;AAEhD,sBAAsB,8BAA8B;;AAEpD;;AAEA;AACA;AACA,yBAAyB,gCAAgC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA,aAAa,uDAAa;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,wDAAwD,qBAAqB;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,4BAA4B;AAC5B;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,8CAA8C;;AAE9C,GAAG;;AAEH;AACA;AACA,qBAAqB,8BAA8B;AACnD,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,MAAM;AACN;AACA;AACA,qCAAqC;AACrC;AACA;AACA,iCAAiC,oCAAoC;AACrE,oCAAoC,qCAAqC;AACzE;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,uDAAuD;AACvD;AACA;AACA,+BAA+B;AAC/B,kBAAkB,2BAA2B;AAC7C,6CAA6C;AAC7C;AACA,4BAA4B;AAC5B,oCAAoC;AACpC,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iBAAiB,0BAA0B,sEAAsE,YAAY,4CAA4C,EAAE;AAC3K,WAAW,0BAA0B,oEAAoE,YAAY,8CAA8C,EAAE;AACrK,eAAe,0BAA0B,sEAAsE,YAAY,6CAA6C,EAAE;AAC1K,WAAW,wCAAwC,qEAAqE,YAAY,kDAAkD,gCAAgC,EAAE,aAAa,yCAAyC,EAAE;AAChR,WAAW,yCAAyC,sEAAsE,YAAY,qDAAqD,+BAA+B,EAAE;AAC5N;;AAEA;;AAEA;;;AAGA,CAAC;;AAED,GAAG,KAA6B;AAChC;AACA;;AAEe,kEAAG,EAAC","file":"wad.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Wad\"] = factory();\n\telse\n\t\troot[\"Wad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/wad.js\");\n","/*\n    Copyright (c) 2012 DinahMoe AB & Oskar Eriksson\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy,\n    modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n    is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/*global module*/\n(function() {\n\n    var userContext,\n        userInstance,\n        pipe = function(param, val) {\n            param.value = val;\n        },\n        Super = Object.create(null, {\n            activate: {\n                writable: true,\n                value: function(doActivate) {\n                    if (doActivate) {\n                        this.input.disconnect();\n                        this.input.connect(this.activateNode);\n                        if (this.activateCallback) {\n                            this.activateCallback(doActivate);\n                        }\n                    } else {\n                        this.input.disconnect();\n                        this.input.connect(this.output);\n                    }\n                }\n            },\n            bypass: {\n                get: function() {\n                    return this._bypass;\n                },\n                set: function(value) {\n                    if (this._lastBypassValue === value) {\n                        return;\n                    }\n                    this._bypass = value;\n                    this.activate(!value);\n                    this._lastBypassValue = value;\n                }\n            },\n            connect: {\n                value: function(target) {\n                    this.output.connect(target);\n                }\n            },\n            disconnect: {\n                value: function(target) {\n                    this.output.disconnect(target);\n                }\n            },\n            connectInOrder: {\n                value: function(nodeArray) {\n                    var i = nodeArray.length - 1;\n                    while (i--) {\n                        if (!nodeArray[i].connect) {\n                            return console.error(\"AudioNode.connectInOrder: TypeError: Not an AudioNode.\", nodeArray[i]);\n                        }\n                        if (nodeArray[i + 1].input) {\n                            nodeArray[i].connect(nodeArray[i + 1].input);\n                        } else {\n                            nodeArray[i].connect(nodeArray[i + 1]);\n                        }\n                    }\n                }\n            },\n            getDefaults: {\n                value: function() {\n                    var result = {};\n                    for (var key in this.defaults) {\n                        result[key] = this.defaults[key].value;\n                    }\n                    return result;\n                }\n            },\n            automate: {\n                value: function(property, value, duration, startTime) {\n                    var start = startTime ? ~~(startTime / 1000) : userContext.currentTime,\n                        dur = duration ? ~~(duration / 1000) : 0,\n                        _is = this.defaults[property],\n                        param = this[property],\n                        method;\n\n                    if (param) {\n                        if (_is.automatable) {\n                            if (!duration) {\n                                method = \"setValueAtTime\";\n                            } else {\n                                method = \"linearRampToValueAtTime\";\n                                param.cancelScheduledValues(start);\n                                param.setValueAtTime(param.value, start);\n                            }\n                            param[method](value, dur + start);\n                        } else {\n                            param = value;\n                        }\n                    } else {\n                        console.error(\"Invalid Property for \" + this.name);\n                    }\n                }\n            }\n        }),\n        FLOAT = \"float\",\n        BOOLEAN = \"boolean\",\n        STRING = \"string\",\n        INT = \"int\";\n\n    if (typeof module !== \"undefined\" && module.exports) {\n        module.exports = Tuna;\n    } else if (typeof define === \"function\") {\n        window.define(\"Tuna\", definition);\n    } else {\n        window.Tuna = Tuna;\n    }\n\n    function definition() {\n        return Tuna;\n    }\n\n    function Tuna(context) {\n        if (!(this instanceof Tuna)) {\n            return new Tuna(context);\n        }\n\n        var _window = typeof window === \"undefined\" ? {} : window;\n\n        if (!_window.AudioContext) {\n            _window.AudioContext = _window.webkitAudioContext;\n        }\n        if (!context) {\n            console.log(\"tuna.js: Missing audio context! Creating a new context for you.\");\n            context = _window.AudioContext && (new _window.AudioContext());\n        }\n        if (!context) {\n            throw new Error(\"Tuna cannot initialize because this environment does not support web audio.\");\n        }\n        connectify(context);\n        userContext = context;\n        userInstance = this;\n    }\n\n    function connectify(context) {\n        if (context.__connectified__ === true) return;\n\n        var gain = context.createGain(),\n            proto = Object.getPrototypeOf(Object.getPrototypeOf(gain)),\n            oconnect = proto.connect;\n\n        proto.connect = shimConnect;\n        context.__connectified__ = true; // Prevent overriding connect more than once\n\n        function shimConnect() {\n            var node = arguments[0];\n            arguments[0] = Super.isPrototypeOf ? (Super.isPrototypeOf(node) ? node.input : node) : (node.input || node);\n            oconnect.apply(this, arguments);\n            return node;\n        }\n    }\n\n    function dbToWAVolume(db) {\n        return Math.max(0, Math.round(100 * Math.pow(2, db / 6)) / 100);\n    }\n\n    function fmod(x, y) {\n        // http://kevin.vanzonneveld.net\n        // *     example 1: fmod(5.7, 1.3);\n        // *     returns 1: 0.5\n        var tmp, tmp2, p = 0,\n            pY = 0,\n            l = 0.0,\n            l2 = 0.0;\n\n        tmp = x.toExponential().match(/^.\\.?(.*)e(.+)$/);\n        p = parseInt(tmp[2], 10) - (tmp[1] + \"\").length;\n        tmp = y.toExponential().match(/^.\\.?(.*)e(.+)$/);\n        pY = parseInt(tmp[2], 10) - (tmp[1] + \"\").length;\n\n        if (pY > p) {\n            p = pY;\n        }\n\n        tmp2 = (x % y);\n\n        if (p < -100 || p > 20) {\n            // toFixed will give an out of bound error so we fix it like this:\n            l = Math.round(Math.log(tmp2) / Math.log(10));\n            l2 = Math.pow(10, l);\n\n            return (tmp2 / l2).toFixed(l - p) * l2;\n        } else {\n            return parseFloat(tmp2.toFixed(-p));\n        }\n    }\n\n    function sign(x) {\n        if (x === 0) {\n            return 1;\n        } else {\n            return Math.abs(x) / x;\n        }\n    }\n\n    function tanh(n) {\n        return (Math.exp(n) - Math.exp(-n)) / (Math.exp(n) + Math.exp(-n));\n    }\n\n    function initValue(userVal, defaultVal) {\n        return userVal === undefined ? defaultVal : userVal;\n    }\n\n    Tuna.prototype.Bitcrusher = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.bufferSize = properties.bufferSize || this.defaults.bufferSize.value;\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.processor = userContext.createScriptProcessor(this.bufferSize, 1, 1);\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.processor);\n        this.processor.connect(this.output);\n\n        var phaser = 0,\n            last = 0,\n            input, output, step, i, length;\n        this.processor.onaudioprocess = function(e) {\n            input = e.inputBuffer.getChannelData(0),\n            output = e.outputBuffer.getChannelData(0),\n            step = Math.pow(1 / 2, this.bits);\n            length = input.length;\n            for (i = 0; i < length; i++) {\n                phaser += this.normfreq;\n                if (phaser >= 1.0) {\n                    phaser -= 1.0;\n                    last = step * Math.floor(input[i] / step + 0.5);\n                }\n                output[i] = last;\n            }\n        };\n\n        this.bits = properties.bits || this.defaults.bits.value;\n        this.normfreq = initValue(properties.normfreq, this.defaults.normfreq.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Bitcrusher.prototype = Object.create(Super, {\n        name: {\n            value: \"Bitcrusher\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bits: {\n                    value: 4,\n                    min: 1,\n                    max: 16,\n                    automatable: false,\n                    type: INT\n                },\n                bufferSize: {\n                    value: 4096,\n                    min: 256,\n                    max: 16384,\n                    automatable: false,\n                    type: INT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                normfreq: {\n                    value: 0.1,\n                    min: 0.0001,\n                    max: 1.0,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        bits: {\n            enumerable: true,\n            get: function() {\n                return this.processor.bits;\n            },\n            set: function(value) {\n                this.processor.bits = value;\n            }\n        },\n        normfreq: {\n            enumerable: true,\n            get: function() {\n                return this.processor.normfreq;\n            },\n            set: function(value) {\n                this.processor.normfreq = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Cabinet = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.convolver = this.newConvolver(properties.impulsePath || \"../impulses/impulse_guitar.wav\");\n        this.makeupNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.convolver.input);\n        this.convolver.output.connect(this.makeupNode);\n        this.makeupNode.connect(this.output);\n        //don't use makeupGain setter at init to avoid smoothing\n        this.makeupNode.gain.value = initValue(properties.makeupGain, this.defaults.makeupGain.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Cabinet.prototype = Object.create(Super, {\n        name: {\n            value: \"Cabinet\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                makeupGain: {\n                    value: 1,\n                    min: 0,\n                    max: 20,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        makeupGain: {\n            enumerable: true,\n            get: function() {\n                return this.makeupNode.gain;\n            },\n            set: function(value) {\n                this.makeupNode.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        newConvolver: {\n            value: function(impulsePath) {\n                return new userInstance.Convolver({\n                    impulse: impulsePath,\n                    dryLevel: 0,\n                    wetLevel: 1\n                });\n            }\n        }\n    });\n\n    Tuna.prototype.Chorus = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.attenuator = this.activateNode = userContext.createGain();\n        this.splitter = userContext.createChannelSplitter(2);\n        this.delayL = userContext.createDelay();\n        this.delayR = userContext.createDelay();\n        this.feedbackGainNodeLR = userContext.createGain();\n        this.feedbackGainNodeRL = userContext.createGain();\n        this.merger = userContext.createChannelMerger(2);\n        this.output = userContext.createGain();\n\n        this.lfoL = new userInstance.LFO({\n            target: this.delayL.delayTime,\n            callback: pipe\n        });\n        this.lfoR = new userInstance.LFO({\n            target: this.delayR.delayTime,\n            callback: pipe\n        });\n\n        this.input.connect(this.attenuator);\n        this.attenuator.connect(this.output);\n        this.attenuator.connect(this.splitter);\n        this.splitter.connect(this.delayL, 0);\n        this.splitter.connect(this.delayR, 1);\n        this.delayL.connect(this.feedbackGainNodeLR);\n        this.delayR.connect(this.feedbackGainNodeRL);\n        this.feedbackGainNodeLR.connect(this.delayR);\n        this.feedbackGainNodeRL.connect(this.delayL);\n        this.delayL.connect(this.merger, 0, 0);\n        this.delayR.connect(this.merger, 0, 1);\n        this.merger.connect(this.output);\n\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\n        this.rate = initValue(properties.rate, this.defaults.rate.value);\n        this.delay = initValue(properties.delay, this.defaults.delay.value);\n        this.depth = initValue(properties.depth, this.defaults.depth.value);\n        this.lfoR.phase = Math.PI / 2;\n        this.attenuator.gain.value = 0.6934; // 1 / (10 ^ (((20 * log10(3)) / 3) / 20))\n        this.lfoL.activate(true);\n        this.lfoR.activate(true);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Chorus.prototype = Object.create(Super, {\n        name: {\n            value: \"Chorus\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                feedback: {\n                    value: 0.4,\n                    min: 0,\n                    max: 0.95,\n                    automatable: false,\n                    type: FLOAT\n                },\n                delay: {\n                    value: 0.0045,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                depth: {\n                    value: 0.7,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                rate: {\n                    value: 1.5,\n                    min: 0,\n                    max: 8,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        delay: {\n            enumerable: true,\n            get: function() {\n                return this._delay;\n            },\n            set: function(value) {\n                this._delay = 0.0002 * (Math.pow(10, value) * 2);\n                this.lfoL.offset = this._delay;\n                this.lfoR.offset = this._delay;\n                this._depth = this._depth;\n            }\n        },\n        depth: {\n            enumerable: true,\n            get: function() {\n                return this._depth;\n            },\n            set: function(value) {\n                this._depth = value;\n                this.lfoL.oscillation = this._depth * this._delay;\n                this.lfoR.oscillation = this._depth * this._delay;\n            }\n        },\n        feedback: {\n            enumerable: true,\n            get: function() {\n                return this._feedback;\n            },\n            set: function(value) {\n                this._feedback = value;\n                this.feedbackGainNodeLR.gain.setTargetAtTime(this._feedback, userContext.currentTime, 0.01);\n                this.feedbackGainNodeRL.gain.setTargetAtTime(this._feedback, userContext.currentTime, 0.01);\n            }\n        },\n        rate: {\n            enumerable: true,\n            get: function() {\n                return this._rate;\n            },\n            set: function(value) {\n                this._rate = value;\n                this.lfoL.frequency = this._rate;\n                this.lfoR.frequency = this._rate;\n            }\n        }\n    });\n\n    Tuna.prototype.Compressor = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.compNode = this.activateNode = userContext.createDynamicsCompressor();\n        this.makeupNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.compNode.connect(this.makeupNode);\n        this.makeupNode.connect(this.output);\n\n        this.automakeup = initValue(properties.automakeup, this.defaults.automakeup.value);\n\n        //don't use makeupGain setter at initialization to avoid smoothing\n        if (this.automakeup) {\n            this.makeupNode.gain.value = dbToWAVolume(this.computeMakeup());\n        } else {\n            this.makeupNode.gain.value = dbToWAVolume(initValue(properties.makeupGain, this.defaults.makeupGain.value));\n        }\n        this.threshold = initValue(properties.threshold, this.defaults.threshold.value);\n        this.release = initValue(properties.release, this.defaults.release.value);\n        this.attack = initValue(properties.attack, this.defaults.attack.value);\n        this.ratio = properties.ratio || this.defaults.ratio.value;\n        this.knee = initValue(properties.knee, this.defaults.knee.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Compressor.prototype = Object.create(Super, {\n        name: {\n            value: \"Compressor\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                threshold: {\n                    value: -20,\n                    min: -60,\n                    max: 0,\n                    automatable: true,\n                    type: FLOAT\n                },\n                release: {\n                    value: 250,\n                    min: 10,\n                    max: 2000,\n                    automatable: true,\n                    type: FLOAT\n                },\n                makeupGain: {\n                    value: 1,\n                    min: 1,\n                    max: 100,\n                    automatable: true,\n                    type: FLOAT\n                },\n                attack: {\n                    value: 1,\n                    min: 0,\n                    max: 1000,\n                    automatable: true,\n                    type: FLOAT\n                },\n                ratio: {\n                    value: 4,\n                    min: 1,\n                    max: 50,\n                    automatable: true,\n                    type: FLOAT\n                },\n                knee: {\n                    value: 5,\n                    min: 0,\n                    max: 40,\n                    automatable: true,\n                    type: FLOAT\n                },\n                automakeup: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        computeMakeup: {\n            value: function() {\n                var magicCoefficient = 4, // raise me if the output is too hot\n                    c = this.compNode;\n                return -(c.threshold.value - c.threshold.value / c.ratio.value) / magicCoefficient;\n            }\n        },\n        automakeup: {\n            enumerable: true,\n            get: function() {\n                return this._automakeup;\n            },\n            set: function(value) {\n                this._automakeup = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        threshold: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.threshold;\n            },\n            set: function(value) {\n                this.compNode.threshold.value = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        ratio: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.ratio;\n            },\n            set: function(value) {\n                this.compNode.ratio.value = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        knee: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.knee;\n            },\n            set: function(value) {\n                this.compNode.knee.value = value;\n                if (this._automakeup) this.makeupGain = this.computeMakeup();\n            }\n        },\n        attack: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.attack;\n            },\n            set: function(value) {\n                this.compNode.attack.value = value / 1000;\n            }\n        },\n        release: {\n            enumerable: true,\n            get: function() {\n                return this.compNode.release;\n            },\n            set: function(value) {\n                this.compNode.release.value = value / 1000;\n            }\n        },\n        makeupGain: {\n            enumerable: true,\n            get: function() {\n                return this.makeupNode.gain;\n            },\n            set: function(value) {\n                this.makeupNode.gain.setTargetAtTime(dbToWAVolume(value), userContext.currentTime, 0.01);\n            }\n        }\n    });\n\n    Tuna.prototype.Convolver = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.convolver = userContext.createConvolver();\n        this.dry = userContext.createGain();\n        this.filterLow = userContext.createBiquadFilter();\n        this.filterHigh = userContext.createBiquadFilter();\n        this.wet = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.filterLow);\n        this.activateNode.connect(this.dry);\n        this.filterLow.connect(this.filterHigh);\n        this.filterHigh.connect(this.convolver);\n        this.convolver.connect(this.wet);\n        this.wet.connect(this.output);\n        this.dry.connect(this.output);\n\n        //don't use setters at init to avoid smoothing\n        this.dry.gain.value = initValue(properties.dryLevel, this.defaults.dryLevel.value);\n        this.wet.gain.value = initValue(properties.wetLevel, this.defaults.wetLevel.value);\n        this.filterHigh.frequency.value = properties.highCut || this.defaults.highCut.value;\n        this.filterLow.frequency.value = properties.lowCut || this.defaults.lowCut.value;\n        this.output.gain.value = initValue(properties.level, this.defaults.level.value);\n        this.filterHigh.type = \"lowpass\";\n        this.filterLow.type = \"highpass\";\n        this.buffer = properties.impulse || \"../impulses/ir_rev_short.wav\";\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Convolver.prototype = Object.create(Super, {\n        name: {\n            value: \"Convolver\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                highCut: {\n                    value: 22050,\n                    min: 20,\n                    max: 22050,\n                    automatable: true,\n                    type: FLOAT\n                },\n                lowCut: {\n                    value: 20,\n                    min: 20,\n                    max: 22050,\n                    automatable: true,\n                    type: FLOAT\n                },\n                dryLevel: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                wetLevel: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                level: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        lowCut: {\n            get: function() {\n                return this.filterLow.frequency;\n            },\n            set: function(value) {\n                this.filterLow.frequency.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        highCut: {\n            get: function() {\n                return this.filterHigh.frequency;\n            },\n            set: function(value) {\n                this.filterHigh.frequency.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        level: {\n            get: function() {\n                return this.output.gain;\n            },\n            set: function(value) {\n                this.output.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        dryLevel: {\n            get: function() {\n                return this.dry.gain;\n            },\n            set: function(value) {\n                this.dry.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        wetLevel: {\n            get: function() {\n                return this.wet.gain;\n            },\n            set: function(value) {\n                this.wet.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        buffer: {\n            enumerable: false,\n            get: function() {\n                return this.convolver.buffer;\n            },\n            set: function(impulse) {\n                var convolver = this.convolver,\n                    xhr = new XMLHttpRequest();\n                if (!impulse) {\n                    console.log(\"Tuna.Convolver.setBuffer: Missing impulse path!\");\n                    return;\n                }\n                xhr.open(\"GET\", impulse, true);\n                xhr.responseType = \"arraybuffer\";\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4) {\n                        if (xhr.status < 300 && xhr.status > 199 || xhr.status === 302) {\n                            userContext.decodeAudioData(xhr.response, function(buffer) {\n                                convolver.buffer = buffer;\n                            }, function(e) {\n                                if (e) console.log(\"Tuna.Convolver.setBuffer: Error decoding data\" + e);\n                            });\n                        }\n                    }\n                };\n                xhr.send(null);\n            }\n        }\n    });\n\n    Tuna.prototype.Delay = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.dry = userContext.createGain();\n        this.wet = userContext.createGain();\n        this.filter = userContext.createBiquadFilter();\n        this.delay = userContext.createDelay(10);\n        this.feedbackNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.delay);\n        this.activateNode.connect(this.dry);\n        this.delay.connect(this.filter);\n        this.filter.connect(this.feedbackNode);\n        this.feedbackNode.connect(this.delay);\n        this.feedbackNode.connect(this.wet);\n        this.wet.connect(this.output);\n        this.dry.connect(this.output);\n\n        this.delayTime = properties.delayTime || this.defaults.delayTime.value;\n        //don't use setters at init to avoid smoothing\n        this.feedbackNode.gain.value = initValue(properties.feedback, this.defaults.feedback.value);\n        this.wet.gain.value = initValue(properties.wetLevel, this.defaults.wetLevel.value);\n        this.dry.gain.value = initValue(properties.dryLevel, this.defaults.dryLevel.value);\n        this.filter.frequency.value = properties.cutoff || this.defaults.cutoff.value;\n        this.filter.type = \"lowpass\";\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Delay.prototype = Object.create(Super, {\n        name: {\n            value: \"Delay\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                delayTime: {\n                    value: 100,\n                    min: 20,\n                    max: 1000,\n                    automatable: false,\n                    type: FLOAT\n                },\n                feedback: {\n                    value: 0.45,\n                    min: 0,\n                    max: 0.9,\n                    automatable: true,\n                    type: FLOAT\n                },\n                cutoff: {\n                    value: 20000,\n                    min: 20,\n                    max: 20000,\n                    automatable: true,\n                    type: FLOAT\n                },\n                wetLevel: {\n                    value: 0.5,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                dryLevel: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        delayTime: {\n            enumerable: true,\n            get: function() {\n                return this.delay.delayTime;\n            },\n            set: function(value) {\n                this.delay.delayTime.value = value / 1000;\n            }\n        },\n        wetLevel: {\n            enumerable: true,\n            get: function() {\n                return this.wet.gain;\n            },\n            set: function(value) {\n                this.wet.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        dryLevel: {\n            enumerable: true,\n            get: function() {\n                return this.dry.gain;\n            },\n            set: function(value) {\n                this.dry.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        feedback: {\n            enumerable: true,\n            get: function() {\n                return this.feedbackNode.gain;\n            },\n            set: function(value) {\n                this.feedbackNode.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        cutoff: {\n            enumerable: true,\n            get: function() {\n                return this.filter.frequency;\n            },\n            set: function(value) {\n                this.filter.frequency.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        }\n    });\n\n    Tuna.prototype.Filter = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.filter = userContext.createBiquadFilter();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.filter);\n        this.filter.connect(this.output);\n\n        //don't use setters for freq and gain at init to avoid smoothing\n        this.filter.frequency.value = properties.frequency || this.defaults.frequency.value;\n        this.Q = properties.resonance || this.defaults.Q.value;\n        this.filterType = initValue(properties.filterType, this.defaults.filterType.value);\n        this.filter.gain.value = initValue(properties.gain, this.defaults.gain.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Filter.prototype = Object.create(Super, {\n        name: {\n            value: \"Filter\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                frequency: {\n                    value: 800,\n                    min: 20,\n                    max: 22050,\n                    automatable: true,\n                    type: FLOAT\n                },\n                Q: {\n                    value: 1,\n                    min: 0.001,\n                    max: 100,\n                    automatable: true,\n                    type: FLOAT\n                },\n                gain: {\n                    value: 0,\n                    min: -40,\n                    max: 40,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                filterType: {\n                    value: \"lowpass\",\n                    automatable: false,\n                    type: STRING\n                }\n            }\n        },\n        filterType: {\n            enumerable: true,\n            get: function() {\n                return this.filter.type;\n            },\n            set: function(value) {\n                this.filter.type = value;\n            }\n        },\n        Q: {\n            enumerable: true,\n            get: function() {\n                return this.filter.Q;\n            },\n            set: function(value) {\n                this.filter.Q.value = value;\n            }\n        },\n        gain: {\n            enumerable: true,\n            get: function() {\n                return this.filter.gain;\n            },\n            set: function(value) {\n                this.filter.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        frequency: {\n            enumerable: true,\n            get: function() {\n                return this.filter.frequency;\n            },\n            set: function(value) {\n                this.filter.frequency.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        }\n    });\n\n    Tuna.prototype.Gain = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.gainNode = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.gainNode);\n        this.gainNode.connect(this.output);\n\n        //don't use setter at init to avoid smoothing\n        this.gainNode.gain.value = initValue(properties.gain, this.defaults.gain.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Gain.prototype = Object.create(Super, {\n        name: {\n            value: \"Gain\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                gain: {\n                    value: 1.0,\n                    automatable: true,\n                    type: FLOAT\n                }\n            }\n        },\n        gain: {\n            enumerable: true,\n            get: function() {\n                return this.gainNode.gain;\n            },\n            set: function(value) {\n                this.gainNode.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        }\n    });\n\n    Tuna.prototype.MoogFilter = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.bufferSize = properties.bufferSize || this.defaults.bufferSize.value;\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.processor = userContext.createScriptProcessor(this.bufferSize, 1, 1);\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.processor);\n        this.processor.connect(this.output);\n\n        var in1, in2, in3, in4, out1, out2, out3, out4;\n        in1 = in2 = in3 = in4 = out1 = out2 = out3 = out4 = 0.0;\n        var input, output, f, fb, i, length, inputFactor;\n        this.processor.onaudioprocess = function(e) {\n            input = e.inputBuffer.getChannelData(0);\n            output = e.outputBuffer.getChannelData(0);\n            f = this.cutoff * 1.16;\n            inputFactor = 0.35013 * (f * f) * (f * f);\n            fb = this.resonance * (1.0 - 0.15 * f * f);\n            length = input.length;\n            for (i = 0; i < length; i++) {\n                input[i] -= out4 * fb;\n                input[i] *= inputFactor;\n                out1 = input[i] + 0.3 * in1 + (1 - f) * out1; // Pole 1\n                in1 = input[i];\n                out2 = out1 + 0.3 * in2 + (1 - f) * out2; // Pole 2\n                in2 = out1;\n                out3 = out2 + 0.3 * in3 + (1 - f) * out3; // Pole 3\n                in3 = out2;\n                out4 = out3 + 0.3 * in4 + (1 - f) * out4; // Pole 4\n                in4 = out3;\n                output[i] = out4;\n            }\n        };\n\n        this.cutoff = initValue(properties.cutoff, this.defaults.cutoff.value);\n        this.resonance = initValue(properties.resonance, this.defaults.resonance.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.MoogFilter.prototype = Object.create(Super, {\n        name: {\n            value: \"MoogFilter\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bufferSize: {\n                    value: 4096,\n                    min: 256,\n                    max: 16384,\n                    automatable: false,\n                    type: INT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                cutoff: {\n                    value: 0.065,\n                    min: 0.0001,\n                    max: 1.0,\n                    automatable: false,\n                    type: FLOAT\n                },\n                resonance: {\n                    value: 3.5,\n                    min: 0.0,\n                    max: 4.0,\n                    automatable: false,\n                    type: FLOAT\n                }\n            }\n        },\n        cutoff: {\n            enumerable: true,\n            get: function() {\n                return this.processor.cutoff;\n            },\n            set: function(value) {\n                this.processor.cutoff = value;\n            }\n        },\n        resonance: {\n            enumerable: true,\n            get: function() {\n                return this.processor.resonance;\n            },\n            set: function(value) {\n                this.processor.resonance = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Overdrive = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.inputDrive = userContext.createGain();\n        this.waveshaper = userContext.createWaveShaper();\n        this.outputDrive = userContext.createGain();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.inputDrive);\n        this.inputDrive.connect(this.waveshaper);\n        this.waveshaper.connect(this.outputDrive);\n        this.outputDrive.connect(this.output);\n\n        this.ws_table = new Float32Array(this.k_nSamples);\n        this.drive = initValue(properties.drive, this.defaults.drive.value);\n        this.outputGain = initValue(properties.outputGain, this.defaults.outputGain.value);\n        this.curveAmount = initValue(properties.curveAmount, this.defaults.curveAmount.value);\n        this.algorithmIndex = initValue(properties.algorithmIndex, this.defaults.algorithmIndex.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Overdrive.prototype = Object.create(Super, {\n        name: {\n            value: \"Overdrive\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                drive: {\n                    value: 1,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT,\n                    scaled: true\n                },\n                outputGain: {\n                    value: 0,\n                    min: -46,\n                    max: 0,\n                    automatable: true,\n                    type: FLOAT,\n                    scaled: true\n                },\n                curveAmount: {\n                    value: 0.725,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                algorithmIndex: {\n                    value: 0,\n                    min: 0,\n                    max: 5,\n                    automatable: false,\n                    type: INT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        k_nSamples: {\n            value: 8192\n        },\n        drive: {\n            get: function() {\n                return this.inputDrive.gain;\n            },\n            set: function(value) {\n                this._drive = value;\n            }\n        },\n        curveAmount: {\n            get: function() {\n                return this._curveAmount;\n            },\n            set: function(value) {\n                this._curveAmount = value;\n                if (this._algorithmIndex === undefined) {\n                    this._algorithmIndex = 0;\n                }\n                this.waveshaperAlgorithms[this._algorithmIndex](this._curveAmount, this.k_nSamples, this.ws_table);\n                this.waveshaper.curve = this.ws_table;\n            }\n        },\n        outputGain: {\n            get: function() {\n                return this.outputDrive.gain;\n            },\n            set: function(value) {\n                this._outputGain = dbToWAVolume(value);\n                this.outputDrive.gain.setValueAtTime(this._outputGain, userContext.currentTime, 0.01);\n            }\n        },\n        algorithmIndex: {\n            get: function() {\n                return this._algorithmIndex;\n            },\n            set: function(value) {\n                this._algorithmIndex = value;\n                this.curveAmount = this._curveAmount;\n            }\n        },\n        waveshaperAlgorithms: {\n            value: [\n                function(amount, n_samples, ws_table) {\n                    amount = Math.min(amount, 0.9999);\n                    var k = 2 * amount / (1 - amount),\n                        i, x;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        ws_table[i] = (1 + k) * x / (1 + k * Math.abs(x));\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var i, x, y;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        y = ((0.5 * Math.pow((x + 1.4), 2)) - 1) * y >= 0 ? 5.8 : 1.2;\n                        ws_table[i] = tanh(y);\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var i, x, y, a = 1 - amount;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        y = x < 0 ? -Math.pow(Math.abs(x), a + 0.04) : Math.pow(x, a);\n                        ws_table[i] = tanh(y * 2);\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var i, x, y, abx, a = 1 - amount > 0.99 ? 0.99 : 1 - amount;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        abx = Math.abs(x);\n                        if (abx < a) y = abx;\n                        else if (abx > a) y = a + (abx - a) / (1 + Math.pow((abx - a) / (1 - a), 2));\n                        else if (abx > 1) y = abx;\n                        ws_table[i] = sign(x) * y * (1 / ((a + 1) / 2));\n                    }\n                },\n                function(amount, n_samples, ws_table) { // fixed curve, amount doesn't do anything, the distortion is just from the drive\n                    var i, x;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        if (x < -0.08905) {\n                            ws_table[i] = (-3 / 4) * (1 - (Math.pow((1 - (Math.abs(x) - 0.032857)), 12)) + (1 / 3) * (Math.abs(x) - 0.032847)) + 0.01;\n                        } else if (x >= -0.08905 && x < 0.320018) {\n                            ws_table[i] = (-6.153 * (x * x)) + 3.9375 * x;\n                        } else {\n                            ws_table[i] = 0.630035;\n                        }\n                    }\n                },\n                function(amount, n_samples, ws_table) {\n                    var a = 2 + Math.round(amount * 14),\n                        // we go from 2 to 16 bits, keep in mind for the UI\n                        bits = Math.round(Math.pow(2, a - 1)),\n                        // real number of quantization steps divided by 2\n                        i, x;\n                    for (i = 0; i < n_samples; i++) {\n                        x = i * 2 / n_samples - 1;\n                        ws_table[i] = Math.round(x * bits) / bits;\n                    }\n                }\n            ]\n        }\n    });\n\n    Tuna.prototype.Panner = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.panner = userContext.createStereoPanner();\n        this.output = userContext.createGain();\n\n        this.activateNode.connect(this.panner);\n        this.panner.connect(this.output);\n\n        this.pan = initValue(properties.pan, this.defaults.pan.value);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Panner.prototype = Object.create(Super, {\n        name: {\n            value: \"Panner\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                pan: {\n                    value: 0.0,\n                    min: -1.0,\n                    max: 1.0,\n                    automatable: true,\n                    type: FLOAT\n                }\n            }\n        },\n        pan: {\n            enumerable: true,\n            get: function() {\n                return this.panner.pan;\n            },\n            set: function(value) {\n                this.panner.pan.value = value;\n            }\n        }\n    });\n\n    Tuna.prototype.Phaser = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.splitter = this.activateNode = userContext.createChannelSplitter(2);\n        this.filtersL = [];\n        this.filtersR = [];\n        this.feedbackGainNodeL = userContext.createGain();\n        this.feedbackGainNodeR = userContext.createGain();\n        this.merger = userContext.createChannelMerger(2);\n        this.filteredSignal = userContext.createGain();\n        this.output = userContext.createGain();\n        this.lfoL = new userInstance.LFO({\n            target: this.filtersL,\n            callback: this.callback\n        });\n        this.lfoR = new userInstance.LFO({\n            target: this.filtersR,\n            callback: this.callback\n        });\n\n        var i = this.stage;\n        while (i--) {\n            this.filtersL[i] = userContext.createBiquadFilter();\n            this.filtersR[i] = userContext.createBiquadFilter();\n            this.filtersL[i].type = \"allpass\";\n            this.filtersR[i].type = \"allpass\";\n        }\n        this.input.connect(this.splitter);\n        this.input.connect(this.output);\n        this.splitter.connect(this.filtersL[0], 0, 0);\n        this.splitter.connect(this.filtersR[0], 1, 0);\n        this.connectInOrder(this.filtersL);\n        this.connectInOrder(this.filtersR);\n        this.filtersL[this.stage - 1].connect(this.feedbackGainNodeL);\n        this.filtersL[this.stage - 1].connect(this.merger, 0, 0);\n        this.filtersR[this.stage - 1].connect(this.feedbackGainNodeR);\n        this.filtersR[this.stage - 1].connect(this.merger, 0, 1);\n        this.feedbackGainNodeL.connect(this.filtersL[0]);\n        this.feedbackGainNodeR.connect(this.filtersR[0]);\n        this.merger.connect(this.output);\n\n        this.rate = initValue(properties.rate, this.defaults.rate.value);\n        this.baseModulationFrequency = properties.baseModulationFrequency || this.defaults.baseModulationFrequency.value;\n        this.depth = initValue(properties.depth, this.defaults.depth.value);\n        this.feedback = initValue(properties.feedback, this.defaults.feedback.value);\n        this.stereoPhase = initValue(properties.stereoPhase, this.defaults.stereoPhase.value);\n\n        this.lfoL.activate(true);\n        this.lfoR.activate(true);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Phaser.prototype = Object.create(Super, {\n        name: {\n            value: \"Phaser\"\n        },\n        stage: {\n            value: 4\n        },\n        defaults: {\n            writable: true,\n            value: {\n                rate: {\n                    value: 0.1,\n                    min: 0,\n                    max: 8,\n                    automatable: false,\n                    type: FLOAT\n                },\n                depth: {\n                    value: 0.6,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                feedback: {\n                    value: 0.7,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                stereoPhase: {\n                    value: 40,\n                    min: 0,\n                    max: 180,\n                    automatable: false,\n                    type: FLOAT\n                },\n                baseModulationFrequency: {\n                    value: 700,\n                    min: 500,\n                    max: 1500,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        callback: {\n            value: function(filters, value) {\n                for (var stage = 0; stage < 4; stage++) {\n                    filters[stage].frequency.value = value;\n                }\n            }\n        },\n        depth: {\n            get: function() {\n                return this._depth;\n            },\n            set: function(value) {\n                this._depth = value;\n                this.lfoL.oscillation = this._baseModulationFrequency * this._depth;\n                this.lfoR.oscillation = this._baseModulationFrequency * this._depth;\n            }\n        },\n        rate: {\n            get: function() {\n                return this._rate;\n            },\n            set: function(value) {\n                this._rate = value;\n                this.lfoL.frequency = this._rate;\n                this.lfoR.frequency = this._rate;\n            }\n        },\n        baseModulationFrequency: {\n            enumerable: true,\n            get: function() {\n                return this._baseModulationFrequency;\n            },\n            set: function(value) {\n                this._baseModulationFrequency = value;\n                this.lfoL.offset = this._baseModulationFrequency;\n                this.lfoR.offset = this._baseModulationFrequency;\n                this.depth = this._depth;\n            }\n        },\n        feedback: {\n            get: function() {\n                return this._feedback;\n            },\n            set: function(value) {\n                this._feedback = value;\n                this.feedbackGainNodeL.gain.setTargetAtTime(this._feedback, userContext.currentTime, 0.01);\n                this.feedbackGainNodeR.gain.setTargetAtTime(this._feedback, userContext.currentTime, 0.01);\n            }\n        },\n        stereoPhase: {\n            get: function() {\n                return this._stereoPhase;\n            },\n            set: function(value) {\n                this._stereoPhase = value;\n                var newPhase = this.lfoL._phase + this._stereoPhase * Math.PI / 180;\n                newPhase = fmod(newPhase, 2 * Math.PI);\n                this.lfoR._phase = newPhase;\n            }\n        }\n    });\n\n    Tuna.prototype.PingPongDelay = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.wet = userContext.createGain();\n        this.stereoToMonoMix = userContext.createGain();\n        this.feedbackLevel = userContext.createGain();\n        this.output = userContext.createGain();\n        this.delayLeft = userContext.createDelay(10);\n        this.delayRight = userContext.createDelay(10);\n\n        this.activateNode = userContext.createGain();\n        this.splitter = userContext.createChannelSplitter(2);\n        this.merger = userContext.createChannelMerger(2);\n\n        this.activateNode.connect(this.splitter);\n        this.splitter.connect(this.stereoToMonoMix, 0, 0);\n        this.splitter.connect(this.stereoToMonoMix, 1, 0);\n        this.stereoToMonoMix.gain.value = .5;\n        this.stereoToMonoMix.connect(this.wet);\n        this.wet.connect(this.delayLeft);\n        this.feedbackLevel.connect(this.wet);\n        this.delayLeft.connect(this.delayRight);\n        this.delayRight.connect(this.feedbackLevel);\n        this.delayLeft.connect(this.merger, 0, 0);\n        this.delayRight.connect(this.merger, 0, 1);\n        this.merger.connect(this.output);\n        this.activateNode.connect(this.output);\n\n        this.delayTimeLeft = properties.delayTimeLeft !== undefined ? properties.delayTimeLeft : this.defaults.delayTimeLeft.value;\n        this.delayTimeRight = properties.delayTimeRight !== undefined ? properties.delayTimeRight : this.defaults.delayTimeRight.value;\n        this.feedbackLevel.gain.value = properties.feedback !== undefined ? properties.feedback : this.defaults.feedback.value;\n        this.wet.gain.value = properties.wetLevel !== undefined ? properties.wetLevel : this.defaults.wetLevel.value;\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.PingPongDelay.prototype = Object.create(Super, {\n        name: {\n            value: \"PingPongDelay\"\n        },\n        delayTimeLeft: {\n            enumerable: true,\n            get: function() {\n                return this._delayTimeLeft;\n            },\n            set: function(value) {\n                this._delayTimeLeft = value;\n                this.delayLeft.delayTime.value = value / 1000;\n            }\n        },\n        delayTimeRight: {\n            enumerable: true,\n            get: function() {\n                return this._delayTimeRight;\n            },\n            set: function(value) {\n                this._delayTimeRight = value;\n                this.delayRight.delayTime.value = value / 1000;\n            }\n        },\n        wetLevel: {\n            enumerable: true,\n            get: function () {\n                return this.wet.gain;\n            },\n            set: function (value) {\n                this.wet.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        }, \n        feedback: {\n            enumerable: true,\n            get: function () {\n                return this.feedbackLevel.gain;\n            },\n            set: function (value) {\n                this.feedbackLevel.gain.setTargetAtTime(value, userContext.currentTime, 0.01);\n            }\n        },\n        defaults: {\n            writable: true,\n            value: {\n                delayTimeLeft: {\n                    value: 200,\n                    min: 1,\n                    max: 10000,\n                    automatable: false,\n                    type: INT\n                },\n                delayTimeRight: {\n                    value: 400,\n                    min: 1,\n                    max: 10000,\n                    automatable: false,\n                    type: INT\n                },\n                feedback: {\n                    value: 0.3,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                wetLevel: {\n                    value: 0.5,\n                    min: 0,\n                    max: 1,\n                    automatable: true,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        }\n    });\n\n    Tuna.prototype.Tremolo = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.splitter = this.activateNode = userContext.createChannelSplitter(2);\n        this.amplitudeL = userContext.createGain();\n        this.amplitudeR = userContext.createGain();\n        this.merger = userContext.createChannelMerger(2);\n        this.output = userContext.createGain();\n        this.lfoL = new userInstance.LFO({\n            target: this.amplitudeL.gain,\n            callback: pipe\n        });\n        this.lfoR = new userInstance.LFO({\n            target: this.amplitudeR.gain,\n            callback: pipe\n        });\n\n        this.input.connect(this.splitter);\n        this.splitter.connect(this.amplitudeL, 0);\n        this.splitter.connect(this.amplitudeR, 1);\n        this.amplitudeL.connect(this.merger, 0, 0);\n        this.amplitudeR.connect(this.merger, 0, 1);\n        this.merger.connect(this.output);\n\n        this.rate = properties.rate || this.defaults.rate.value;\n        this.intensity = initValue(properties.intensity, this.defaults.intensity.value);\n        this.stereoPhase = initValue(properties.stereoPhase, this.defaults.stereoPhase.value);\n\n        this.lfoL.offset = 1 - (this.intensity / 2);\n        this.lfoR.offset = 1 - (this.intensity / 2);\n        this.lfoL.phase = this.stereoPhase * Math.PI / 180;\n\n        this.lfoL.activate(true);\n        this.lfoR.activate(true);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.Tremolo.prototype = Object.create(Super, {\n        name: {\n            value: \"Tremolo\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                intensity: {\n                    value: 0.3,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                stereoPhase: {\n                    value: 0,\n                    min: 0,\n                    max: 180,\n                    automatable: false,\n                    type: FLOAT\n                },\n                rate: {\n                    value: 5,\n                    min: 0.1,\n                    max: 11,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        intensity: {\n            enumerable: true,\n            get: function() {\n                return this._intensity;\n            },\n            set: function(value) {\n                this._intensity = value;\n                this.lfoL.offset = 1 - this._intensity / 2;\n                this.lfoR.offset = 1 - this._intensity / 2;\n                this.lfoL.oscillation = this._intensity;\n                this.lfoR.oscillation = this._intensity;\n            }\n        },\n        rate: {\n            enumerable: true,\n            get: function() {\n                return this._rate;\n            },\n            set: function(value) {\n                this._rate = value;\n                this.lfoL.frequency = this._rate;\n                this.lfoR.frequency = this._rate;\n            }\n        },\n        stereoPhase: {\n            enumerable: true,\n            get: function() {\n                return this._stereoPhase;\n            },\n            set: function(value) {\n                this._stereoPhase = value;\n                var newPhase = this.lfoL._phase + this._stereoPhase * Math.PI / 180;\n                newPhase = fmod(newPhase, 2 * Math.PI);\n                this.lfoR.phase = newPhase;\n            }\n        }\n    });\n\n    Tuna.prototype.WahWah = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.activateNode = userContext.createGain();\n        this.envelopeFollower = new userInstance.EnvelopeFollower({\n            target: this,\n            callback: function(context, value) {\n                context.sweep = value;\n            }\n        });\n        this.filterBp = userContext.createBiquadFilter();\n        this.filterPeaking = userContext.createBiquadFilter();\n        this.output = userContext.createGain();\n\n        //Connect AudioNodes\n        this.activateNode.connect(this.filterBp);\n        this.filterBp.connect(this.filterPeaking);\n        this.filterPeaking.connect(this.output);\n\n        //Set Properties\n        this.init();\n        this.automode = initValue(properties.automode, this.defaults.automode.value);\n        this.resonance = properties.resonance || this.defaults.resonance.value;\n        this.sensitivity = initValue(properties.sensitivity, this.defaults.sensitivity.value);\n        this.baseFrequency = initValue(properties.baseFrequency, this.defaults.baseFrequency.value);\n        this.excursionOctaves = properties.excursionOctaves || this.defaults.excursionOctaves.value;\n        this.sweep = initValue(properties.sweep, this.defaults.sweep.value);\n\n        this.activateNode.gain.value = 2;\n        this.envelopeFollower.activate(true);\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.WahWah.prototype = Object.create(Super, {\n        name: {\n            value: \"WahWah\"\n        },\n        defaults: {\n            writable: true,\n            value: {\n                automode: {\n                    value: true,\n                    automatable: false,\n                    type: BOOLEAN\n                },\n                baseFrequency: {\n                    value: 0.5,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                excursionOctaves: {\n                    value: 2,\n                    min: 1,\n                    max: 6,\n                    automatable: false,\n                    type: FLOAT\n                },\n                sweep: {\n                    value: 0.2,\n                    min: 0,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                resonance: {\n                    value: 10,\n                    min: 1,\n                    max: 100,\n                    automatable: false,\n                    type: FLOAT\n                },\n                sensitivity: {\n                    value: 0.5,\n                    min: -1,\n                    max: 1,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        automode: {\n            get: function() {\n                return this._automode;\n            },\n            set: function(value) {\n                this._automode = value;\n                if (value) {\n                    this.activateNode.connect(this.envelopeFollower.input);\n                    this.envelopeFollower.activate(true);\n                } else {\n                    this.envelopeFollower.activate(false);\n                    this.activateNode.disconnect();\n                    this.activateNode.connect(this.filterBp);\n                }\n            }\n        },\n        filterFreqTimeout: {\n            value: 0\n        },\n        setFilterFreq: {\n            value: function() {\n                try {\n                    this.filterBp.frequency.value = Math.min(22050, this._baseFrequency + this._excursionFrequency * this._sweep);\n                    this.filterPeaking.frequency.value = Math.min(22050, this._baseFrequency + this._excursionFrequency * this._sweep);\n                } catch (e) {\n                    clearTimeout(this.filterFreqTimeout);\n                    //put on the next cycle to let all init properties be set\n                    this.filterFreqTimeout = setTimeout(function() {\n                        this.setFilterFreq();\n                    }.bind(this), 0);\n                }\n            }\n        },\n        sweep: {\n            enumerable: true,\n            get: function() {\n                return this._sweep;\n            },\n            set: function(value) {\n                this._sweep = Math.pow(value > 1 ? 1 : value < 0 ? 0 : value, this._sensitivity);\n                this.setFilterFreq();\n            }\n        },\n        baseFrequency: {\n            enumerable: true,\n            get: function() {\n                return this._baseFrequency;\n            },\n            set: function(value) {\n                this._baseFrequency = 50 * Math.pow(10, value * 2);\n                this._excursionFrequency = Math.min(userContext.sampleRate / 2, this.baseFrequency * Math.pow(2, this._excursionOctaves));\n                this.setFilterFreq();\n            }\n        },\n        excursionOctaves: {\n            enumerable: true,\n            get: function() {\n                return this._excursionOctaves;\n            },\n            set: function(value) {\n                this._excursionOctaves = value;\n                this._excursionFrequency = Math.min(userContext.sampleRate / 2, this.baseFrequency * Math.pow(2, this._excursionOctaves));\n                this.setFilterFreq();\n            }\n        },\n        sensitivity: {\n            enumerable: true,\n            get: function() {\n                return this._sensitivity;\n            },\n            set: function(value) {\n                this._sensitivity = Math.pow(10, value);\n            }\n        },\n        resonance: {\n            enumerable: true,\n            get: function() {\n                return this._resonance;\n            },\n            set: function(value) {\n                this._resonance = value;\n                this.filterPeaking.Q = this._resonance;\n            }\n        },\n        init: {\n            value: function() {\n                this.output.gain.value = 1;\n                this.filterPeaking.type = \"peaking\";\n                this.filterBp.type = \"bandpass\";\n                this.filterPeaking.frequency.value = 100;\n                this.filterPeaking.gain.value = 20;\n                this.filterPeaking.Q.value = 5;\n                this.filterBp.frequency.value = 100;\n                this.filterBp.Q.value = 1;\n            }\n        }\n    });\n\n    Tuna.prototype.EnvelopeFollower = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n        this.input = userContext.createGain();\n        this.jsNode = this.output = userContext.createScriptProcessor(this.buffersize, 1, 1);\n\n        this.input.connect(this.output);\n\n        this.attackTime = initValue(properties.attackTime, this.defaults.attackTime.value);\n        this.releaseTime = initValue(properties.releaseTime, this.defaults.releaseTime.value);\n        this._envelope = 0;\n        this.target = properties.target || {};\n        this.callback = properties.callback || function() {};\n\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.EnvelopeFollower.prototype = Object.create(Super, {\n        name: {\n            value: \"EnvelopeFollower\"\n        },\n        defaults: {\n            value: {\n                attackTime: {\n                    value: 0.003,\n                    min: 0,\n                    max: 0.5,\n                    automatable: false,\n                    type: FLOAT\n                },\n                releaseTime: {\n                    value: 0.5,\n                    min: 0,\n                    max: 0.5,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        buffersize: {\n            value: 256\n        },\n        envelope: {\n            value: 0\n        },\n        sampleRate: {\n            value: 44100\n        },\n        attackTime: {\n            enumerable: true,\n            get: function() {\n                return this._attackTime;\n            },\n            set: function(value) {\n                this._attackTime = value;\n                this._attackC = Math.exp(-1 / this._attackTime * this.sampleRate / this.buffersize);\n            }\n        },\n        releaseTime: {\n            enumerable: true,\n            get: function() {\n                return this._releaseTime;\n            },\n            set: function(value) {\n                this._releaseTime = value;\n                this._releaseC = Math.exp(-1 / this._releaseTime * this.sampleRate / this.buffersize);\n            }\n        },\n        callback: {\n            get: function() {\n                return this._callback;\n            },\n            set: function(value) {\n                if (typeof value === \"function\") {\n                    this._callback = value;\n                } else {\n                    console.error(\"tuna.js: \" + this.name + \": Callback must be a function!\");\n                }\n            }\n        },\n        target: {\n            get: function() {\n                return this._target;\n            },\n            set: function(value) {\n                this._target = value;\n            }\n        },\n        activate: {\n            value: function(doActivate) {\n                this.activated = doActivate;\n                if (doActivate) {\n                    this.jsNode.connect(userContext.destination);\n                    this.jsNode.onaudioprocess = this.returnCompute(this);\n                } else {\n                    this.jsNode.disconnect();\n                    this.jsNode.onaudioprocess = null;\n                }\n                if (this.activateCallback) {\n                    this.activateCallback(doActivate);\n                }\n            }\n        },\n        returnCompute: {\n            value: function(instance) {\n                return function(event) {\n                    instance.compute(event);\n                };\n            }\n        },\n        compute: {\n            value: function(event) {\n                var count = event.inputBuffer.getChannelData(0).length,\n                    channels = event.inputBuffer.numberOfChannels,\n                    current, chan, rms, i;\n                chan = rms = i = 0;\n                if (channels > 1) { //need to mixdown\n                    for (i = 0; i < count; ++i) {\n                        for (; chan < channels; ++chan) {\n                            current = event.inputBuffer.getChannelData(chan)[i];\n                            rms += (current * current) / channels;\n                        }\n                    }\n                } else {\n                    for (i = 0; i < count; ++i) {\n                        current = event.inputBuffer.getChannelData(0)[i];\n                        rms += (current * current);\n                    }\n                }\n                rms = Math.sqrt(rms);\n\n                if (this._envelope < rms) {\n                    this._envelope *= this._attackC;\n                    this._envelope += (1 - this._attackC) * rms;\n                } else {\n                    this._envelope *= this._releaseC;\n                    this._envelope += (1 - this._releaseC) * rms;\n                }\n                this._callback(this._target, this._envelope);\n            }\n        }\n    });\n\n    Tuna.prototype.LFO = function(properties) {\n        if (!properties) {\n            properties = this.getDefaults();\n        }\n\n        //Instantiate AudioNode\n        this.input = userContext.createGain();\n        this.output = userContext.createScriptProcessor(256, 1, 1);\n        this.activateNode = userContext.destination;\n\n        //Set Properties\n        this.frequency = initValue(properties.frequency, this.defaults.frequency.value);\n        this.offset = initValue(properties.offset, this.defaults.offset.value);\n        this.oscillation = initValue(properties.oscillation, this.defaults.oscillation.value);\n        this.phase = initValue(properties.phase, this.defaults.phase.value);\n        this.target = properties.target || {};\n        this.output.onaudioprocess = this.callback(properties.callback || function() {});\n        this.bypass = properties.bypass || this.defaults.bypass.value;\n    };\n    Tuna.prototype.LFO.prototype = Object.create(Super, {\n        name: {\n            value: \"LFO\"\n        },\n        bufferSize: {\n            value: 256\n        },\n        sampleRate: {\n            value: 44100\n        },\n        defaults: {\n            value: {\n                frequency: {\n                    value: 1,\n                    min: 0,\n                    max: 20,\n                    automatable: false,\n                    type: FLOAT\n                },\n                offset: {\n                    value: 0.85,\n                    min: 0,\n                    max: 22049,\n                    automatable: false,\n                    type: FLOAT\n                },\n                oscillation: {\n                    value: 0.3,\n                    min: -22050,\n                    max: 22050,\n                    automatable: false,\n                    type: FLOAT\n                },\n                phase: {\n                    value: 0,\n                    min: 0,\n                    max: 2 * Math.PI,\n                    automatable: false,\n                    type: FLOAT\n                },\n                bypass: {\n                    value: false,\n                    automatable: false,\n                    type: BOOLEAN\n                }\n            }\n        },\n        frequency: {\n            get: function() {\n                return this._frequency;\n            },\n            set: function(value) {\n                this._frequency = value;\n                this._phaseInc = 2 * Math.PI * this._frequency * this.bufferSize / this.sampleRate;\n            }\n        },\n        offset: {\n            get: function() {\n                return this._offset;\n            },\n            set: function(value) {\n                this._offset = value;\n            }\n        },\n        oscillation: {\n            get: function() {\n                return this._oscillation;\n            },\n            set: function(value) {\n                this._oscillation = value;\n            }\n        },\n        phase: {\n            get: function() {\n                return this._phase;\n            },\n            set: function(value) {\n                this._phase = value;\n            }\n        },\n        target: {\n            get: function() {\n                return this._target;\n            },\n            set: function(value) {\n                this._target = value;\n            }\n        },\n        activate: {\n            value: function(doActivate) {\n                if (doActivate) {\n                    this.output.connect(userContext.destination);\n                    if (this.activateCallback) {\n                        this.activateCallback(doActivate);\n                    }\n                } else {\n                    this.output.disconnect();\n                }\n            }\n        },\n        callback: {\n            value: function(callback) {\n                var that = this;\n                return function() {\n                    that._phase += that._phaseInc;\n                    if (that._phase > 2 * Math.PI) {\n                        that._phase = 0;\n                    }\n                    callback(that._target, that._offset + that._oscillation * Math.sin(that._phase));\n                };\n            }\n        }\n    });\n\n    Tuna.toString = Tuna.prototype.toString = function() {\n        return \"Please visit https://github.com/Theodeus/tuna/wiki for instructions on how to use Tuna.js\";\n    };\n})();\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/*below is the es6. It was transpiled to es5 from:\r\nhttps://babeljs.io/en/repl\r\nsearch for:\r\n// start of ES5\r\nto get there\r\n\r\nexport default class SoundIterator{\r\n\tstatic defaultArgs = {\r\n\t\tfiles: [], // either sound files or Wad audio objects\r\n\t\trandom: false, // either play a random order (true), or play in the order of the list (false)\r\n\t\trandomPlaysBeforeRepeat: 0, // This value says the amount of plays that need to happen before a sound can be repeated. This only works if the length of the iterator is 3 or more, and this value is max 1 less than the length of the sound list.\r\n\t}\r\n\r\n\tconstructor(args, Wad){\r\n\t\tthis.Wad = Wad //passed in from the Wad object that creates this iterator\r\n\t\targs = Object.assign({}, SoundIterator.defaultArgs, args)\r\n\t\tthis.files = args.files\r\n\t\tthis.sounds = this.files.map(f=>f.play ? f : new Wad({source:f})) // checks if the item in the list is a wad or not.\r\n\t\tthis.randomSounds = this.sounds.slice() //creates a list of sounds that can be mutated if there are random sounds\r\n\t\tthis.random = args.random\r\n\t\tthis.randomPlaysBeforeRepeat = this.sounds.length > 3 && args.randomPlaysBeforeRepeat < sounds.length-1 ? args.randomPlaysBeforeRepeat : 0\r\n\t\tthis.index = 0 // keeps track of what item in the list is playing\r\n\t\tthis.waitingSounds = [] //has a list of the sounds that are waiting from randomPlaysBeforeRepeat\r\n\t}\r\n\r\n\tplay(args={}){\r\n\t\tif(!this.sounds.length) return 0\r\n\t\tif(this.random){\r\n\t\t\tconst soundIndex = Math.floor(Math.random()*this.randomSounds.length)\r\n\t\t\tconst sound = this.randomSounds[soundIndex]\r\n\t\t\tthis.index = this.sounds.indexOf(sound)\r\n\t\t\tthis.waitingSounds = this.waitingSounds.filter(soundObj=>{\r\n\t\t\t\tsoundObj.plays -= 1\r\n\t\t\t\tif(soundObj.plays < 1){\r\n\t\t\t\t\tthis.randomSounds.push(soundObj.sound)\r\n\t\t\t\t\treturn null\r\n\t\t\t\t}\r\n\t\t\t\treturn true\r\n\t\t\t})\r\n\t\t\tif(this.randomPlaysBeforeRepeat){\r\n\t\t\t\tthis.randomSounds.splice(soundIndex, 1)\r\n\t\t\t\tthis.waitingSounds.push({plays: this.randomPlaysBeforeRepeat, sound: sound})\r\n\t\t\t}\r\n\t\t\treturn sound.play(args)\r\n\t\t} else {\r\n\t\t\tconst playingSound = this.sounds[this.index] ? this.sounds[this.index].play(args) : undefined\r\n\t\t\tthis.index += 1\r\n\t\t\tif(this.index >= this.sounds.length){\r\n\t\t\t\tthis.index = 0\r\n\t\t\t}\r\n\t\t\treturn playingSound    \r\n\t\t}\r\n\t}\r\n\r\n\tadd(sound){\r\n\t\tif(!sound.play){\r\n\t\t\tsound = new this.Wad({source: sound})\r\n\t\t}\r\n\t\tthis.sounds.push(sound)\r\n\t\tthis.randomSounds.push(sound)\r\n\t\treturn this\r\n\t}\r\n\r\n\tremove(sound){\r\n\t\tconst soundIndex = this.sounds.indexOf(sound)\r\n\t\tif(soundIndex === -1){\r\n\t\t\tthrow new Error(`That sound does not exist: ${sound}`)\r\n\t\t}\r\n\t\tthis.sounds.splice(soundIndex, 1)\r\n\t\tconst randomSoundIndex = this.randomSounds.indexOf(sound)\r\n\t\tif(randomSoundIndex === -1){\r\n\t\t\tthis.waitingSounds = this.waitingSounds.filter(obj => obj.sound === sound ? false : true)\r\n\t\t} else {\r\n\t\t\tthis.randomSounds.splice(randomSoundIndex, 1)\r\n\t\t}\r\n\t\treturn this\r\n\t}\r\n}\r\n*/\r\n\r\n// start of ES5\r\n\"use strict\";\r\n\r\nfunction _instanceof(left, right) { if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\r\n\r\nvar SoundIterator =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function SoundIterator(args, Wad) {\r\n    _classCallCheck(this, SoundIterator);\r\n\r\n    this.Wad = Wad; //passed in from the Wad object that creates this iterator\r\n\r\n    args = Object.assign({}, SoundIterator.defaultArgs, args);\r\n    this.files = args.files;\r\n    this.sounds = this.files.map(function (f) {\r\n      return f.play ? f : new Wad({\r\n        source: f\r\n      });\r\n    }); // checks if the item in the list is a wad or not.\r\n\r\n    this.randomSounds = this.sounds.slice(); //creates a list of sounds that can be mutated if there are random sounds\r\n\r\n    this.random = args.random;\r\n    this.randomPlaysBeforeRepeat = this.sounds.length > 3 && args.randomPlaysBeforeRepeat < sounds.length - 1 ? args.randomPlaysBeforeRepeat : 0;\r\n    this.index = 0; // keeps track of what item in the list is playing\r\n\r\n    this.waitingSounds = []; //has a list of the sounds that are waiting from randomPlaysBeforeRepeat\r\n  }\r\n\r\n  _createClass(SoundIterator, [{\r\n    key: \"play\",\r\n    value: function play() {\r\n      var _this = this;\r\n\r\n      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n      if (!this.sounds.length) return 0;\r\n\r\n      if (this.random) {\r\n        var soundIndex = Math.floor(Math.random() * this.randomSounds.length);\r\n        var sound = this.randomSounds[soundIndex];\r\n        this.index = this.sounds.indexOf(sound);\r\n        this.waitingSounds = this.waitingSounds.filter(function (soundObj) {\r\n          soundObj.plays -= 1;\r\n\r\n          if (soundObj.plays < 1) {\r\n            _this.randomSounds.push(soundObj.sound);\r\n\r\n            return null;\r\n          }\r\n\r\n          return true;\r\n        });\r\n\r\n        if (this.randomPlaysBeforeRepeat) {\r\n          this.randomSounds.splice(soundIndex, 1);\r\n          this.waitingSounds.push({\r\n            plays: this.randomPlaysBeforeRepeat,\r\n            sound: sound\r\n          });\r\n        }\r\n\r\n        return sound.play(args);\r\n      } else {\r\n        var playingSound = this.sounds[this.index] ? this.sounds[this.index].play(args) : undefined;\r\n        this.index += 1;\r\n\r\n        if (this.index >= this.sounds.length) {\r\n          this.index = 0;\r\n        }\r\n\r\n        return playingSound;\r\n      }\r\n    }\r\n  }, {\r\n    key: \"add\",\r\n    value: function add(sound) {\r\n      if (!sound.play) {\r\n        sound = new this.Wad({\r\n          source: sound\r\n        });\r\n      }\r\n\r\n      this.sounds.push(sound);\r\n      this.randomSounds.push(sound);\r\n      return this;\r\n    }\r\n  }, {\r\n    key: \"remove\",\r\n    value: function remove(sound) {\r\n      var soundIndex = this.sounds.indexOf(sound);\r\n\r\n      if (soundIndex === -1) {\r\n        throw new Error(\"That sound does not exist: \".concat(sound));\r\n      }\r\n\r\n      this.sounds.splice(soundIndex, 1);\r\n      var randomSoundIndex = this.randomSounds.indexOf(sound);\r\n\r\n      if (randomSoundIndex === -1) {\r\n        this.waitingSounds = this.waitingSounds.filter(function (obj) {\r\n          return obj.sound === sound ? false : true;\r\n        });\r\n      } else {\r\n        this.randomSounds.splice(randomSoundIndex, 1);\r\n      }\r\n\r\n      return this;\r\n    }\r\n  }]);\r\n\r\n  return SoundIterator;\r\n}();\r\n\r\n_defineProperty(SoundIterator, \"defaultArgs\", {\r\n  files: [],\r\n  // either sound files or Wad audio objects\r\n  random: false,\r\n  // either play a random order (true), or play in the order of the list (false)\r\n  randomPlaysBeforeRepeat: 0 // This value says the amount of plays that need to happen before a sound can be repeated. This only works if the length of the iterator is 3 or more, and this value is max 1 less than the length of the sound list.\r\n\r\n});\r\nexport default SoundIterator","import Tuna from 'tunajs';\r\nimport SoundIterator from './sound_iterator'\r\n\r\n\r\nvar Wad = (function(){\r\n\r\n\tvar audioContext = window.AudioContext || window.webkitAudioContext;\r\n\r\n\tvar logStuff = {\r\n\t\tverbosity: 0,\r\n\t\tsuppressedLogs: 0\r\n\t}\r\n\r\n\tvar logMessage = function(message, logLevel){\r\n\t\tvar logLevel = logLevel || 1\r\n\t\tif ( logStuff.verbosity >= logLevel ) {\r\n\t\t\tconsole.log(message)\r\n\t\t} \r\n\t\telse { logStuff.suppressedLogs++ }\r\n\t}\r\n\t\r\n\tvar aScene = document.querySelector('a-scene');\r\n\tvar context;\r\n\tif ( aScene && aScene.audioListener && aScene.audioListener.context){\r\n\t\tcontext = aScene.audioListener.context\r\n\t\tlogMessage(\"An A-Frame scene has been detected.\")\r\n\t}\r\n\telse {\r\n\t\tcontext = new audioContext();\r\n\t}\r\n\tvar unlock = function(){\r\n\t\tif ( context.state === 'suspended' ) {\r\n\t\t\tcontext.resume()\r\n\t\t}\r\n\t\telse if ( context.state === 'running' ) {\r\n\t\t\tlogMessage(\"The audio context is running.\")\r\n\t\t\tlogMessage(context)\r\n\t\t\twindow.removeEventListener('mousemove', unlock)\r\n\t\t\twindow.removeEventListener('touchstart', unlock)\r\n\t\t\twindow.removeEventListener('touchend', unlock)\r\n\t\t}\r\n\t}\r\n\twindow.addEventListener('mousemove', unlock)\r\n\twindow.addEventListener('touchstart', unlock)\r\n\twindow.addEventListener('touchend', unlock)\r\n\t// create a wrapper for old versions of `getUserMedia`\r\n\tvar getUserMedia = (function(window) {\r\n\t\tif (window.navigator.mediaDevices && window.navigator.mediaDevices.getUserMedia) {\r\n\t\t\t// Browser supports promise based `getUserMedia`\r\n\t\t\treturn window.navigator.mediaDevices.getUserMedia.bind(window.navigator.mediaDevices);\r\n\t\t}\r\n\t\tvar navigatorGetUserMedia = window.navigator.getUserMedia || window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia;\r\n\t\tif (navigatorGetUserMedia) {\r\n\t\t\t// Browser supports old `getUserMedia` with callbacks.\r\n\t\t\treturn function(constraints) {\r\n\t\t\t\treturn new Promise(function(resolve, reject) {\r\n\t\t\t\t\tnavigatorGetUserMedia.call(window.navigator, constraints, resolve, reject);\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\treturn function() {\r\n\t\t\tthrow \"getUserMedia is unsupported\";\r\n\t\t};\r\n\t}(window));\r\n\t\r\n\tif (getUserMedia) { logMessage(\"Your browser supports getUserMedia.\"); }\r\n\telse { logMessage(\"Your browser does not support getUserMedia.\"); }\r\n\r\n\r\n/** Pre-render a noise buffer instead of generating noise on the fly. **/\r\n\tvar noiseBuffer = (function(){\r\n\t\t// the initial seed\r\n\t\tMath.seed = 6;\r\n\t\tMath.seededRandom = function(max, min){\r\n\t\t\tmax = max || 1;\r\n\t\t\tmin = min || 0;\r\n\t\t\tMath.seed = ( Math.seed * 9301 + 49297 ) % 233280;\r\n\t\t\tvar rnd = Math.seed / 233280;\r\n\r\n\t\t\treturn min + rnd * (max - min);\r\n\t\t}\r\n\t\tvar bufferSize = 2 * context.sampleRate;\r\n\t\tvar noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate);\r\n\t\tvar output = noiseBuffer.getChannelData(0);\r\n\t\tfor ( var i = 0; i < bufferSize; i++ ) {\r\n\t\t\toutput[i] = Math.seededRandom() * 2 - 1;\r\n\t\t}\r\n\t\treturn noiseBuffer;\r\n\t})()\r\n/////////////////////////////////////////////////////////////////////////\r\n\r\n/** a lil hack. just be glad it isn't on Object.prototype. **/\r\n\tvar isArray = function(object){\r\n\t\treturn Object.prototype.toString.call(object) === '[object Array]';\r\n\t}\r\n\r\n/** Set up the default ADSR envelope. **/\r\n\tvar constructEnv = function(that, arg){\r\n\t\tthat.env = { //default envelope, if one is not specified on play\r\n\t\t\tattack  : arg.env ? valueOrDefault(arg.env.attack,  0) : 0,\t// time in seconds from onset to peak volume\r\n\t\t\tdecay   : arg.env ? valueOrDefault(arg.env.decay,   0) : 0,\t// time in seconds from peak volume to sustain volume\r\n\t\t\tsustain : arg.env ? valueOrDefault(arg.env.sustain, 1) : 1,\t// sustain volume level, as a percent of peak volume. min:0, max:1\r\n\t\t\thold\t: arg.env ? valueOrDefault(arg.env.hold, 3.14159) : 3.14159, // time in seconds to maintain sustain volume\r\n\t\t\trelease : arg.env ? valueOrDefault(arg.env.release, 0) : 0\t // time in seconds from sustain volume to zero volume\r\n\t\t};\r\n\t\tthat.defaultEnv = {\r\n\t\t\tattack  : arg.env ? valueOrDefault(arg.env.attack,  0) : 0,\t// time in seconds from onset to peak volume\r\n\t\t\tdecay   : arg.env ? valueOrDefault(arg.env.decay,   0) : 0,\t// time in seconds from peak volume to sustain volume\r\n\t\t\tsustain : arg.env ? valueOrDefault(arg.env.sustain, 1) : 1,\t// sustain volume level, as a percent of peak volume. min:0, max:1\r\n\t\t\thold\t: arg.env ? valueOrDefault(arg.env.hold, 3.14159) : 3.14159, // time in seconds to maintain sustain volume\r\n\t\t\trelease : arg.env ? valueOrDefault(arg.env.release, 0) : 0\t // time in seconds from sustain volume to zero volume\r\n\t\t};\r\n\t\tthat.userSetHold = !!(arg.env && arg.env.hold)\r\n\t}\r\n/////////////////////////////////////////\r\n\r\n\r\n/** Set up the default filter and filter envelope. **/\r\n\tvar constructFilter = function(that, arg){\r\n\r\n\t\tif ( !arg.filter ) { arg.filter = null; }\r\n\r\n\t\telse if ( isArray(arg.filter) ) {\r\n\t\t\tthat.filter = arg.filter.map(function(filterArg){\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype : filterArg.type || 'lowpass',\r\n\t\t\t\t\tfrequency : filterArg.frequency || 600,\r\n\t\t\t\t\tq : filterArg.q || 1,\r\n\t\t\t\t\tenv : filterArg.env || null,\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthat.filter  = [{\r\n\t\t\t\ttype : arg.filter.type || 'lowpass',\r\n\t\t\t\tfrequency : arg.filter.frequency || 600,\r\n\t\t\t\tq : arg.filter.q || 1,\r\n\t\t\t\tenv : arg.filter.env ||null,\r\n\t\t\t}];\r\n\t\t}\r\n\t}\r\n//////////////////////////////////////////////////////\r\n\r\n\r\n/** If the Wad uses an audio file as the source, request it from the server.\r\nDon't let the Wad play until all necessary files have been downloaded. **/\r\n\tvar requestAudioFile = function(that, callback){\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.open(\"GET\", that.source, true);\r\n\t\trequest.responseType = \"arraybuffer\";\r\n\t\tthat.playable--;\r\n\t\trequest.onload = function(){\r\n\t\t\tcontext.decodeAudioData(request.response, function (decodedBuffer){\r\n\t\t\t\tthat.decodedBuffer = decodedBuffer;\r\n\t\t\t\tif ( that.env.hold === 3.14159 ) { // audio buffers should not use the default hold\r\n\t\t\t\t\tthat.defaultEnv.hold = that.decodedBuffer.duration\r\n\t\t\t\t\tthat.env.hold = that.decodedBuffer.duration\r\n\t\t\t\t}\r\n\t\t\t\tthat.duration = (that.env.attack + that.env.decay + that.env.hold + that.env.release) * (1/(that.rate)) * 1000\r\n\r\n\t\t\t\tif ( callback ) { callback(that); }\r\n\t\t\t\tthat.playable++;\r\n\t\t\t\tif ( that.playOnLoad ) { that.play(that.playOnLoadArg); }\r\n\t\t\t})\r\n\t\t};\r\n\t\trequest.send();\r\n\t};\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n/** Set up the vibrato LFO **/\r\n\tvar constructVibrato = function(that, arg){\r\n\t\tif ( arg.vibrato ) {\r\n\t\t\tthat.vibrato = {\r\n\t\t\t\tshape\t : valueOrDefault(arg.vibrato.shape, 'sine'),\r\n\t\t\t\tspeed\t : valueOrDefault(arg.vibrato.speed, 1),\r\n\t\t\t\tmagnitude : valueOrDefault(arg.vibrato.magnitude, 5),\r\n\t\t\t\tattack\t: valueOrDefault(arg.vibrato.attack, 0)\r\n\t\t\t};\r\n\t\t}\r\n\t\telse { that.vibrato = null; }\r\n\t};\r\n//////////////////////////////\r\n\r\n\r\n/** Set up the tremolo LFO **/\r\n\tvar constructTremolo = function(that, arg){\r\n\t\tif ( arg.tremolo ) {\r\n\t\t\tthat.tremolo = {\r\n\t\t\t\tshape\t : valueOrDefault(arg.tremolo.shape, 'sine'),\r\n\t\t\t\tspeed\t : valueOrDefault(arg.tremolo.speed, 1),\r\n\t\t\t\tmagnitude : valueOrDefault(arg.tremolo.magnitude, 5),\r\n\t\t\t\tattack\t: valueOrDefault(arg.tremolo.attack, 1)\r\n\t\t\t};\r\n\t\t}\r\n\t\telse { that.tremolo = null; }\r\n\t};\r\n//////////////////////////////\r\n\r\n/** Grab the reverb impulse response file from a server.\r\nYou may want to change Wad.defaultImpulse to serve files from your own server.\r\nCheck out http://www.voxengo.com/impulses/ for free impulse responses. **/\r\n\tvar constructReverb = function(that, arg){\r\n\t\tif ( arg.reverb ) {\r\n\t\t\tthat.reverb = { wet : valueOrDefault(arg.reverb.wet, 1) };\r\n\t\t\tvar impulseURL = arg.reverb.impulse || Wad.defaultImpulse;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", impulseURL, true);\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\tthat.playable--;\r\n\t\t\trequest.onload = function(){\r\n\t\t\t\tcontext.decodeAudioData(request.response, function (decodedBuffer){\r\n\r\n\t\t\t\t\tthat.reverb.buffer = decodedBuffer;\r\n\t\t\t\t\tthat.playable++;\r\n\t\t\t\t\tif ( that.playOnLoad ) { that.play(that.playOnLoadArg); }\r\n\t\t\t\t\tif ( that instanceof Wad.Poly ) { that.setUp(arg); }\r\n\t\t\t\t\tif ( that.source === 'mic' && that.reverb && that.reverb.buffer && that.reverb.node && !that.reverb.node.buffer ) { // I think this is only relevant when calling play() with args on a mic\r\n\t\t\t\t\t\tthat.reverb.node.convolver.buffer = that.reverb.buffer;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t})\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthat.reverb = null;\r\n\t\t}\r\n\t};\r\n\r\n\tvar constructPanning = function(that, arg){\r\n\t\tif ( 'panning' in arg ) {\r\n\t\t\tthat.panning = { location : arg.panning };\r\n\t\t\tif ( typeof(arg.panning) === \"number\" ) {\r\n\t\t\t\tthat.panning.type = 'stereo';\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tthat.panning.type = '3d'\r\n\t\t\t\tthat.panning.panningModel   = arg.panningModel || 'equalpower';\r\n\t\t\t\tthat.panning.distanceModel  = arg.distanceModel \r\n\t\t\t\tthat.panning.maxDistance\t= arg.maxDistance \r\n\t\t\t\tthat.panning.rolloffFactor  = arg.rolloffFactor\r\n\t\t\t\tthat.panning.refDistance\t= arg.refDistance\r\n\t\t\t\tthat.panning.coneInnerAngle = arg.coneInnerAngle\r\n\t\t\t\tthat.panning.coneOuterAngle = arg.coneOuterAngle\r\n\t\t\t\tthat.panning.coneOuterGain  = arg.coneOuterGain\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\tthat.panning = {\r\n\t\t\t\tlocation : 0,\r\n\t\t\t\ttype\t : 'stereo',\r\n\t\t\t};\r\n\t\t}\r\n\t\tif ( that.panning.type === 'stereo' && !context.createStereoPanner ) {\r\n\t\t\tlogMessage(\"Your browser does not support stereo panning. Falling back to 3D panning.\")\r\n\t\t\tthat.panning = {\r\n\t\t\t\tlocation\t : [0,0,0],\r\n\t\t\t\ttype\t\t : '3d',\r\n\t\t\t\tpanningModel : 'equalpower',\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n//////////////////////////////////////////////////////////////////////////////\r\n\tvar constructDelay = function(that, arg){\r\n\t\tif ( arg.delay ) {\r\n\t\t\tthat.delay = {\r\n\t\t\t\tdelayTime\t: valueOrDefault(arg.delay.delayTime, .5),\r\n\t\t\t\tmaxDelayTime : valueOrDefault(arg.delay.maxDelayTime, 2),\r\n\t\t\t\tfeedback\t : valueOrDefault(arg.delay.feedback, .25),\r\n\t\t\t\twet\t\t  : valueOrDefault(arg.delay.wet, .25)\r\n\t\t\t};\r\n\t\t}\r\n\t\telse { that.delay = null; }\r\n\t};\r\n/** Special initialization and configuration for microphone Wads **/\r\n\tvar getConsent = function(that, arg) {\r\n\t\tthat.nodes\t\t\t = [];\r\n\t\tthat.mediaStreamSource = null;\r\n\t\tthat.gain\t\t\t  = null;\r\n\t\treturn getUserMedia({audio: true, video: false}).then(function(stream) {\r\n\t\t\tthat.mediaStreamSource = context.createMediaStreamSource(stream);\r\n\t\t\tWad.micConsent = true\r\n\t\t\tsetUpMic(that, arg);\r\n\t\t\treturn that;\r\n\t\t}).catch(function(error) { logMessage('Error setting up microphone input: ', error); }); // This is the error callback.\r\n\t};\r\n////////////////////////////////////////////////////////////////////\r\n\r\n\tvar setUpMic = function(that, arg){\r\n\t\tthat.nodes\t\t   = [];\r\n\t\tthat.gain\t\t\t= context.createGain();\r\n\t\tthat.gain.gain.value = valueOrDefault(arg.volume,that.volume);\r\n\t\tthat.nodes.push(that.mediaStreamSource);\r\n\t\tthat.nodes.push(that.gain);\r\n  \r\n\r\n\t\tif ( that.filter || arg.filter ) { createFilters(that, arg); }\r\n\r\n\t\tif ( that.reverb || arg.reverb ) { setUpReverbOnPlay(that, arg); }\r\n\r\n\t\tconstructPanning(that, arg);\r\n\t\tsetUpPanningOnPlay(that, arg);\r\n\r\n\t\tif ( that.delay || arg.delay ) {\r\n\t\t\tsetUpDelayOnPlay(that, arg);\r\n\t\t}\r\n\t\tsetUpTunaOnPlay(that, arg)\r\n\t\tthat.setUpExternalFxOnPlay(arg, context);\r\n\t}\r\n\r\n\tvar allWads = []\r\n\r\n\tvar Wad = function(arg){\r\n/** Set basic Wad properties **/\r\n\t\tthis.source\t\t= arg.source;\r\n\t\tthis.destination   = arg.destination || context.destination; // the last node the sound is routed to\r\n\t\tthis.volume\t\t= valueOrDefault(arg.volume, 1); // peak volume. min:0, max:1 (actually max is infinite, but ...just keep it at or below 1)\r\n\t\tthis.defaultVolume = this.volume;\r\n\t\tthis.playable\t  = 1; // if this is less than 1, this Wad is still waiting for a file to download before it can play\r\n\t\tthis.pitch\t\t = Wad.pitches[arg.pitch] || arg.pitch || 440;\r\n\t\tthis.gain\t\t  = [];\r\n\t\tthis.detune\t\t= arg.detune || 0; // In Cents.\r\n\t\tthis.globalReverb  = arg.globalReverb || false;\r\n\t\tthis.offset\t\t= arg.offset || 0;\r\n\t\tthis.loop\t\t  = arg.loop   || false;\r\n\t\tthis.tuna\t\t  = arg.tuna   || null;\r\n\t\tthis.rate\t\t  = arg.rate   || 1;\r\n\t\tthis.sprite\t\t= arg.sprite || null;\r\n\t\tconstructEnv(this, arg);\r\n\t\tconstructFilter(this, arg);\r\n\t\tconstructVibrato(this, arg);\r\n\t\tconstructTremolo(this, arg);\r\n\t\tconstructReverb(this, arg);\r\n\t\tthis.constructExternalFx(arg, context);\r\n\t\tconstructPanning(this, arg);\r\n\t\tconstructDelay(this, arg);\r\n\t\tthis.duration = (this.env.attack + this.env.decay + this.env.hold + this.env.release) * (1/(this.rate)) * 1000\r\n////////////////////////////////\r\n\r\n\r\n/** If the Wad's source is noise, set the Wad's buffer to the noise buffer we created earlier. **/\r\n\t\tif ( this.source === 'noise' ) {\r\n\t\t\tthis.decodedBuffer = noiseBuffer;\r\n\t\t}\r\n//////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/** If the Wad's source is the microphone, the rest of the setup happens here. **/\r\n\t\telse if ( this.source === 'mic' ) {\r\n\t\t\tgetConsent(this, arg);\r\n\t\t}\r\n//////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/** If the source is not a pre-defined value, assume it is a URL for an audio file, and grab it now. **/\r\n\t\telse if ( !( this.source in { 'sine' : 0, 'sawtooth' : 0, 'square' : 0, 'triangle' : 0 } ) ) {\r\n\t\t\trequestAudioFile(this, arg.callback);\r\n\r\n\t\t\tif ( this.sprite ) {\r\n\t\t\t\tvar thatWad = this;\r\n\t\t\t\tfor ( var sprite in this.sprite ) {\r\n\t\t\t\t\tthis[sprite] = {\r\n\t\t\t\t\t\tsprite: this.sprite[sprite],\r\n\t\t\t\t\t\tplay: function(arg){\r\n\t\t\t\t\t\t\targ = arg || {}\r\n\t\t\t\t\t\t\targ.env = arg.env || {}\r\n\t\t\t\t\t\t\targ.env.hold = this.sprite[1] - this.sprite[0]\r\n\t\t\t\t\t\t\targ.offset = this.sprite[0]\r\n\r\n\t\t\t\t\t\t\treturn thatWad.play(arg)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\telse { arg.callback && arg.callback(this) }\r\n\t\tallWads.push(this)\r\n\t};\r\n\tWad.allWads = allWads\r\n\tWad.micConsent = false\r\n\tWad.audioContext = context\r\n\tif ( typeof Tuna != undefined ) {\r\n\t\tWad.tuna = new Tuna(Wad.audioContext)\r\n\t}\r\n\r\n\r\n/** When a note is played, these two functions will schedule changes in volume and filter frequency,\r\nas specified by the volume envelope and filter envelope **/\r\n\tvar filterEnv = function(wad, arg){\r\n\t\twad.filter.forEach(function (filter, index){\r\n\t\t\tfilter.node.frequency.linearRampToValueAtTime(filter.frequency, arg.exactTime);\r\n\t\t\tfilter.node.frequency.linearRampToValueAtTime(filter.env.frequency, arg.exactTime + filter.env.attack);\r\n\t\t});\r\n\t};\r\n\r\n\tvar playEnv = function(wad, arg){\r\n\t\tvar loop = arg.loop || arg.loop\r\n\t\tif ( wad.env.hold === -1 || (loop && !wad.userSetHold && !(arg.env && arg.env.hold) ) ){\r\n\t\t\tvar hold = 999\r\n\t\t}\r\n\t\telse { var hold = wad.env.hold }\r\n\t\twad.gain[0].gain.linearRampToValueAtTime(0.0001, arg.exactTime);\r\n\t\twad.gain[0].gain.linearRampToValueAtTime(wad.volume, arg.exactTime + wad.env.attack + 0.00001);\r\n\t\twad.gain[0].gain.linearRampToValueAtTime(wad.volume * wad.env.sustain, arg.exactTime + wad.env.attack + wad.env.decay + 0.00002);\r\n\t\twad.gain[0].gain.linearRampToValueAtTime(wad.volume * wad.env.sustain, arg.exactTime + wad.env.attack + wad.env.decay + hold + 0.00003);\r\n\t\twad.gain[0].gain.linearRampToValueAtTime(0.0001, arg.exactTime + wad.env.attack + wad.env.decay + hold + wad.env.release + 0.00004);\r\n\t\t// offset is only used by BufferSourceNodes. OscillatorNodes should safely ignore the offset.\r\n\t\twad.soundSource.start(arg.exactTime, arg.offset);\r\n\t\twad.soundSource.stop(arg.exactTime + wad.env.attack + wad.env.decay + hold + wad.env.release);\r\n\t};\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/** When all the nodes are set up for this Wad, this function plugs them into each other,\r\nwith special handling for nodes with custom interfaces (e.g. reverb, delay). **/\r\n\tvar plugEmIn = function(that, arg){\r\n\t\tvar destination = ( arg && arg.destination ) || that.destination;\r\n\t\tfor ( var i = 1; i < that.nodes.length; i++ ) {\r\n\t\t\tif ( that.nodes[i-1].interface === 'custom' ) {\r\n\t\t\t\tvar from = that.nodes[i-1].output;\r\n\t\t\t}\r\n\t\t\telse { // assume native interface\r\n\t\t\t\tvar from = that.nodes[i-1];\r\n\t\t\t}\r\n\t\t\tif ( that.nodes[i].interface === 'custom' ) {\r\n\t\t\t\tvar to = that.nodes[i].input\r\n\t\t\t}\r\n\t\t\telse { // assume native interface\r\n\t\t\t\tvar to = that.nodes[i]\r\n\t\t\t}\r\n\t\t\tfrom.connect(to);\r\n\t\t}\r\n\t\tif ( that.nodes[that.nodes.length-1].interface === 'custom') {\r\n\t\t\tvar lastStop = that.nodes[that.nodes.length-1].output;\r\n\t\t}\r\n\t\telse { // assume native interface\r\n\t\t\tvar lastStop = that.nodes[that.nodes.length-1];\r\n\t\t}\r\n\t\tlastStop.connect(destination);\r\n\r\n\t\t/** Global reverb is super deprecated, and should be removed at some point. **/\r\n\t\tif ( Wad.reverb && that.globalReverb ) {\r\n\t\t\tthat.nodes[that.nodes.length - 1].connect(Wad.reverb.node);\r\n\t\t\tWad.reverb.node.connect(Wad.reverb.gain);\r\n\t\t\tWad.reverb.gain.connect(destination);\r\n\t\t}\r\n\t\t/**************************************************************************/\r\n\t};\r\n/////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/** Initialize and configure an oscillator node **/\r\n\tvar setUpOscillator = function(that, arg){\r\n\t\targ = arg || {};\r\n\t\tthat.soundSource = context.createOscillator();\r\n\t\tthat.soundSource.type = that.source;\r\n\t\tif ( arg.pitch ) {\r\n\t\t\tif ( arg.pitch in Wad.pitches ) {\r\n\t\t\t\tthat.soundSource.frequency.value = Wad.pitches[arg.pitch];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthat.soundSource.frequency.value = arg.pitch;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthat.soundSource.frequency.value = that.pitch;\r\n\t\t}\r\n\t};\r\n///////////////////////////////////////////////////\r\n\r\n/** Set the ADSR volume envelope according to play() arguments, or revert to defaults **/\r\n\tvar setUpEnvOnPlay = function(that, arg){\r\n\t\tif ( arg && arg.env ) {\r\n\t\t\tthat.env.attack  = valueOrDefault(arg.env.attack, that.defaultEnv.attack);\r\n\t\t\tthat.env.decay   = valueOrDefault(arg.env.decay, that.defaultEnv.decay);\r\n\t\t\tthat.env.sustain = valueOrDefault(arg.env.sustain, that.defaultEnv.sustain);\r\n\t\t\tthat.env.hold\t= valueOrDefault(arg.env.hold, that.defaultEnv.hold);\r\n\t\t\tthat.env.release = valueOrDefault(arg.env.release, that.defaultEnv.release);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthat.env = {\r\n\t\t\t\tattack  : that.defaultEnv.attack,\r\n\t\t\t\tdecay   : that.defaultEnv.decay,\r\n\t\t\t\tsustain : that.defaultEnv.sustain,\r\n\t\t\t\thold\t: that.defaultEnv.hold,\r\n\t\t\t\trelease : that.defaultEnv.release\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t};\r\n//////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n/** Set the filter and filter envelope according to play() arguments, or revert to defaults **/\r\n\r\n\tvar createFilters = function(that, arg){\r\n\t\tif ( arg.filter && !isArray(arg.filter) ) {\r\n\t\t\targ.filter = [arg.filter];\r\n\t\t}\r\n\t\tthat.filter.forEach(function (filter, i) {\r\n\t\t\tfilter.node\t\t\t\t = context.createBiquadFilter();\r\n\t\t\tfilter.node.type\t\t\t= filter.type;\r\n\t\t\tfilter.node.frequency.value = ( arg.filter && arg.filter[i] ) ? ( arg.filter[i].frequency || filter.frequency ) : filter.frequency;\r\n\t\t\tfilter.node.Q.value\t\t = ( arg.filter && arg.filter[i] ) ? ( arg.filter[i].q\t\t || filter.q )\t\t : filter.q;\r\n\t\t\tif ( ( arg.filter && arg.filter[i].env || that.filter[i].env ) && !( that.source === \"mic\" ) ) {\r\n\t\t\t\tfilter.env = {\r\n\t\t\t\t\tattack\t: ( arg.filter && arg.filter[i].env && arg.filter[i].env.attack )\t|| that.filter[i].env.attack,\r\n\t\t\t\t\tfrequency : ( arg.filter && arg.filter[i].env && arg.filter[i].env.frequency ) || that.filter[i].env.frequency\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tthat.nodes.push(filter.node);\r\n\t\t})\r\n\t};\r\n\r\n\tvar setUpFilterOnPlay = function(that, arg){\r\n\t\tif ( arg && arg.filter && that.filter ) {\r\n\t\t\tif ( !isArray(arg.filter) ) arg.filter = [arg.filter]\r\n\t\t\tcreateFilters(that, arg)\r\n\t\t}\r\n\t\telse if ( that.filter ) {\r\n\t\t\tcreateFilters(that, that);\r\n\t\t}\r\n\t};\r\n///////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n/** Initialize and configure a convolver node for playback **/\r\n\tvar setUpReverbOnPlay = function(that, arg){\r\n\t\tvar reverbNode = {\r\n\t\t\tinterface : 'custom',\r\n\t\t\tinput : context.createGain(),\r\n\t\t\tconvolver : context.createConvolver(),\r\n\t\t\twet : context.createGain(),\r\n\t\t\toutput : context.createGain()\r\n\t\t}\r\n\t\treverbNode.convolver.buffer = that.reverb.buffer;\r\n\t\treverbNode.wet.gain.value   = that.reverb.wet;\r\n\r\n\t\treverbNode.input.connect(reverbNode.convolver);\r\n\t\treverbNode.input.connect(reverbNode.output);\r\n\t\treverbNode.convolver.connect(reverbNode.wet);\r\n\t\treverbNode.wet.connect(reverbNode.output);\r\n\r\n\t\tthat.reverb.node = reverbNode;\r\n\t\tthat.nodes.push(that.reverb.node);\r\n\t};\r\n//////////////////////////////////////////////////////////////\r\n\r\n\r\n/** Initialize and configure a panner node for playback **/\r\n\tvar setUpPanningOnPlay = function(that, arg){\r\n\t\tvar panning = arg && arg.panning; // can be zero provided as argument\r\n\t\tif (typeof panning === 'undefined') { panning = that.panning.location; }\r\n\r\n\t\tif (typeof panning  === 'number') {\r\n\t\t\tthat.panning.node = context.createStereoPanner();\r\n\t\t\tthat.panning.node.pan.value = panning;\r\n\t\t\tthat.panning.type = 'stereo';\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthat.panning.node = context.createPanner();\r\n\t\t\tthat.panning.node.setPosition(panning[0], panning[1], panning[2]);\r\n\t\t\tthat.panning.node.panningModel = arg.panningModel || that.panningModel || 'equalpower';\r\n\t\t\tthat.panning.type = '3d';\r\n\r\n\t\t\tthat.panning.node.distanceModel  = arg.distanceModel  || that.distanceModel  || that.panning.node.distanceModel\r\n\t\t\tthat.panning.node.maxDistance\t= arg.maxDistance\t|| that.maxDistance\t|| that.panning.node.maxDistance\r\n\t\t\tthat.panning.node.rolloffFactor  = arg.rolloffFactor  || that.rolloffFactor  || that.panning.node.rolloffFactor\r\n\t\t\tthat.panning.node.refDistance\t= arg.refDistance\t|| that.refDistance\t|| that.panning.node.refDistance\r\n\t\t\tthat.panning.node.coneInnerAngle = arg.coneInnerAngle || that.coneInnerAngle || that.panning.node.coneInnerAngle\r\n\t\t\tthat.panning.node.coneOuterAngle = arg.coneOuterAngle || that.coneOuterAngle || that.panning.node.coneOuterAngle\r\n\t\t\tthat.panning.node.coneOuterGain  = arg.coneOuterGain  || that.coneOuterGain  || that.panning.node.coneOuterGain\r\n\t\t}\r\n\r\n\t\tthat.nodes.push(that.panning.node);\r\n\r\n\t};\r\n///////////////////////////////////////////////////////////\r\n\r\n\r\n/** Initialize and configure a vibrato LFO Wad for playback **/\r\n\tvar setUpVibratoOnPlay = function(that, arg){\r\n\t\tthat.vibrato.wad = new Wad({\r\n\t\t\tsource : that.vibrato.shape,\r\n\t\t\tpitch  : that.vibrato.speed,\r\n\t\t\tvolume : that.vibrato.magnitude,\r\n\t\t\tenv\t: {\r\n\t\t\t\tattack : that.vibrato.attack\r\n\t\t\t},\r\n\t\t\tdestination : that.soundSource.frequency\r\n\t\t});\r\n\t\tthat.vibrato.wad.play();\r\n\t};\r\n///////////////////////////////////////////////////////////////\r\n\r\n\r\n/** Initialize and configure a tremolo LFO Wad for playback **/\r\n\tvar setUpTremoloOnPlay = function(that, arg){\r\n\t\tthat.tremolo.wad = new Wad({\r\n\t\t\tsource : that.tremolo.shape,\r\n\t\t\tpitch  : that.tremolo.speed,\r\n\t\t\tvolume : that.tremolo.magnitude,\r\n\t\t\tenv\t: {\r\n\t\t\t\tattack : that.tremolo.attack,\r\n\t\t\t\thold   : 10\r\n\t\t\t},\r\n\t\t\tdestination : that.gain[0].gain\r\n\t\t});\r\n\t\tthat.tremolo.wad.play();\r\n\t};\r\n///////////////////////////////////////////////////////////////\r\n\r\n\tvar setUpDelayOnPlay = function(that, arg){\r\n\t\tif ( that.delay ) {\r\n\t\t\tif ( !arg.delay ) { arg.delay = {}; }\r\n\t\t\t//create the nodes well use\r\n\t\t\tvar delayNode = { // the custom delay node\r\n\t\t\t\tinterface\t: 'custom',\r\n\t\t\t\tinput\t\t: context.createGain(),\r\n\t\t\t\toutput\t   : context.createGain(),\r\n\t\t\t\tdelayNode\t: context.createDelay(that.delay.maxDelayTime), // the native delay node inside the custom delay node.\r\n\t\t\t\tfeedbackNode : context.createGain(),\r\n\t\t\t\twetNode\t  : context.createGain(),\r\n\t\t\t}\r\n\r\n\t\t\t//set some decent values\r\n\t\t\tdelayNode.delayNode.delayTime.value = valueOrDefault(arg.delay.delayTime, that.delay.delayTime);\r\n\t\t\tdelayNode.feedbackNode.gain.value   = valueOrDefault(arg.delay.feedback, that.delay.feedback);\r\n\t\t\tdelayNode.wetNode.gain.value\t\t= valueOrDefault(arg.delay.wet, that.delay.wet);\r\n\r\n\r\n\t\t\t//set up the routing\r\n\t\t\tdelayNode.input.connect(delayNode.delayNode);\r\n\t\t\tdelayNode.input.connect(delayNode.output);\r\n\t\t\tdelayNode.delayNode.connect(delayNode.feedbackNode);\r\n\t\t\tdelayNode.delayNode.connect(delayNode.wetNode);\r\n\t\t\tdelayNode.feedbackNode.connect(delayNode.delayNode);\r\n\t\t\tdelayNode.wetNode.connect(delayNode.output);\r\n\t\t\tthat.delay.delayNode = delayNode;\r\n\r\n\t\t\tthat.nodes.push(delayNode)\r\n\t\t}\r\n\t};\r\n\r\n/** **/\r\n\tvar constructCompressor = function(that, arg){\r\n\t\tthat.compressor = context.createDynamicsCompressor();\r\n\t\tthat.compressor.attack.value\t= valueOrDefault(arg.compressor.attack, that.compressor.attack.value);\r\n\t\tthat.compressor.knee.value\t  = valueOrDefault(arg.compressor.knee, that.compressor.knee.value);\r\n\t\tthat.compressor.ratio.value\t = valueOrDefault(arg.compressor.ratio, that.compressor.ratio.value);\r\n\t\tthat.compressor.release.value   = valueOrDefault(arg.compressor.release, that.compressor.release.value);\r\n\t\tthat.compressor.threshold.value = valueOrDefault(arg.compressor.threshold, that.compressor.threshold.value);\r\n\t\tthat.nodes.push(that.compressor);\r\n\t};\r\n\tvar setUpTunaOnPlay = function(that, arg){\r\n\t\tif ( !( that.tuna || arg.tuna ) ) { return }\r\n\t\tvar tunaConfig = {}\r\n\t\tif ( that.tuna ) {\r\n\t\t\tfor ( var key in that.tuna ) {\r\n\t\t\t\ttunaConfig[key] = that.tuna[key]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// overwrite settings from `this` with settings from arg\r\n\t\tif ( arg.tuna ) {\r\n\t\t\tfor ( var key in arg.tuna ) {\r\n\t\t\t\ttunaConfig[key] = arg.tuna[key]\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor ( var key in tunaConfig) {\r\n\t\t\tvar tunaEffect = new Wad.tuna[key](tunaConfig[key])\r\n\t\t\tthat.nodes.push(tunaEffect)\r\n\t\t}\r\n\t}\r\n///\r\n\r\n/** Method to allow users to setup external fx in the constructor **/\r\n\tWad.prototype.constructExternalFx = function(arg, context){\r\n\t\t//override me in your own code\r\n\t};\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n/** To be overrided by the user **/\r\n\tWad.prototype.setUpExternalFxOnPlay = function(arg, context){\r\n\t\t//user does what is necessary here, and then maybe does something like:\r\n\t\t// this.nodes.push(externalFX)\r\n\t};\r\n///////////////////////////////////////////////////////////////\r\n\r\n\r\n/** the play() method will create the various nodes that are required for this Wad to play,\r\nset properties on those nodes according to the constructor arguments and play() arguments,\r\nplug the nodes into each other with plugEmIn(),\r\nthen finally play the sound by calling playEnv() **/\r\n\tWad.prototype.play = function(arg){\r\n\t\targ = arg || { arg : null };\r\n\t\tif ( this.playable < 1 ) {\r\n\t\t\tthis.playOnLoad\t= true;\r\n\t\t\tthis.playOnLoadArg = arg;\r\n\t\t}\r\n\r\n\t\telse if ( this.source === 'mic' ) {\r\n\t\t\tif ( Wad.micConsent ) {\r\n\t\t\t\tif ( arg.arg === null ) {\r\n\t\t\t\t\tplugEmIn(this, arg);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconstructFilter(this, arg);\r\n\t\t\t\t\tconstructVibrato(this, arg);\r\n\t\t\t\t\tconstructTremolo(this, arg);\r\n\t\t\t\t\tconstructReverb(this, arg);\r\n\t\t\t\t\tthis.constructExternalFx(arg, context);\r\n\t\t\t\t\tconstructPanning(this, arg);\r\n\t\t\t\t\tconstructDelay(this, arg);\r\n\t\t\t\t\tsetUpMic(this, arg);\r\n\t\t\t\t\tplugEmIn(this, arg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { \r\n\t\t\t\tlogMessage('You have not given your browser permission to use your microphone.')\r\n\t\t\t\tgetConsent(this, arg).then(function (that) {\r\n\t\t\t\t\tthat.play(arg);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\tthis.nodes = [];\r\n\t\t\tif ( !arg.wait ) { arg.wait = 0; }\r\n\t\t\tif ( arg.volume ) { this.volume = arg.volume; }\r\n\t\t\telse { this.volume = this.defaultVolume; }\r\n\t\t\targ.offset = arg.offset || this.offset || 0;\r\n\t\t\tif ( this.source in { 'sine' : 0, 'sawtooth' : 0, 'square' : 0, 'triangle' : 0 } ) {\r\n\t\t\t\tsetUpOscillator(this, arg);\r\n\t\t\t}\r\n\r\n\t\t\telse {\r\n\t\t\t\tthis.soundSource = context.createBufferSource();\r\n\t\t\t\tthis.soundSource.buffer = this.decodedBuffer;\r\n\t\t\t\tif ( this.source === 'noise' || this.loop || arg.loop ) {\r\n\t\t\t\t\tthis.soundSource.loop = true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.soundSource.playbackRate ) {\r\n\t\t\t\tthis.soundSource.playbackRate.value = arg.rate || this.rate;\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.soundSource.detune ) {\r\n\t\t\t\tthis.soundSource.detune.value = arg.detune || this.detune;\r\n\t\t\t}\r\n\r\n\t\t\tif ( arg.wait === undefined ) {\r\n\t\t\t\targ.wait = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (arg.exactTime === undefined) {\r\n\t\t\t\targ.exactTime = context.currentTime + arg.wait;\r\n\t\t\t}\r\n\t\t\tthis.lastPlayedTime = arg.exactTime\r\n\r\n\t\t\tthis.nodes.push(this.soundSource);\r\n\r\n\r\n\t/**  sets the volume envelope based on the play() arguments if present,\r\n\tor defaults to the constructor arguments if the volume envelope is not set on play() **/\r\n\t\t\tsetUpEnvOnPlay(this, arg);\r\n\t////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\t/**  sets up the filter and filter envelope based on the play() argument if present,\r\n\tor defaults to the constructor argument if the filter and filter envelope are not set on play() **/\r\n\t\t\tsetUpFilterOnPlay(this, arg);\r\n\t///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\t\tsetUpTunaOnPlay(this, arg);\r\n\r\n\t\t\tthis.setUpExternalFxOnPlay(arg, context);\r\n\r\n\r\n\t\t\tthis.gain.unshift(context.createGain()); // sets up the gain node\r\n\t\t\tthis.gain[0].label = arg.label;\r\n\t\t\tthis.nodes.push(this.gain[0]);\r\n\r\n\t\t\tif ( this.gain.length > 15 ) {\r\n\t\t\t\tthis.gain.length = 15\r\n\t\t\t}\r\n\r\n\t\t\t// sets up reverb\r\n\t\t\tif ( this.reverb ) { setUpReverbOnPlay(this, arg); }\r\n\r\n\t/**  sets panning based on the play() argument if present, or defaults to the constructor argument if panning is not set on play **/\r\n\t\t\tsetUpPanningOnPlay(this, arg);\r\n\t////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\t\t\tsetUpDelayOnPlay(this, arg);\r\n\r\n\t\t\tplugEmIn(this, arg);\r\n\r\n\t\t\tif ( this.filter && this.filter[0].env ) { filterEnv(this, arg); }\r\n\t\t\tplayEnv(this, arg);\r\n\r\n\t\t\t//sets up vibrato LFO\r\n\t\t\tif ( this.vibrato ) { setUpVibratoOnPlay(this, arg); }\r\n\r\n\t\t\t//sets up tremolo LFO\r\n\t\t\tif ( this.tremolo ) { setUpTremoloOnPlay(this, arg); }\r\n\t\t}\r\n\t\tif ( arg.callback ) { arg.callback(this); }\r\n\t\tvar thatWad = this\r\n\t\treturn new Promise(function(resolve, reject){\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\tresolve(thatWad)\r\n\t\t\t}, (arg.wait + thatWad.env.attack + thatWad.env.decay + thatWad.env.hold + thatWad.env.release) * (1/(arg.rate||thatWad.rate||1)) * 1000 )\r\n\t\t})\r\n\r\n\t};\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\t/** Change the volume of a Wad at any time, including during playback **/\r\n\tWad.prototype.setVolume = function(volume){\r\n\t\tthis.defaultVolume = volume;\r\n\t\tif ( this.gain.length > 0 ) { this.gain[0].gain.value = volume; }\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\tChange the playback rate of a Wad during playback.\r\n\tinputSpeed is a value of 0 < speed, and is the rate of playback of the audio.\r\n\tE.g. if input speed = 2.0, the playback will be twice as fast\r\n\t**/\r\n\tWad.prototype.setRate = function(inputSpeed) {\r\n\r\n\t\t//Check/Save the input\r\n\t\tvar speed;\r\n\t\tif(inputSpeed && inputSpeed > 0) speed = inputSpeed;\r\n\t\telse speed = 0;\r\n\r\n\t\t//Check if we have a soundsource (Though we always should)\r\n\t\tif(this.soundSource) {\r\n\r\n\t\t\t//Set the value\r\n\t\t\tthis.soundSource.playbackRate.value = speed;\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t//Inform that there is no delay on the current wad\r\n\t\t\tlogMessage(\"Sorry, but the wad does not contain a soundSource!\");\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\tWad.prototype.setPitch = function(pitch){\r\n\t\tif ( pitch in Wad.pitches ) {\r\n\t\t\tif ( this.soundSource ) {\r\n\t\t\t\tthis.soundSource.frequency.value = Wad.pitches[pitch];\r\n\t\t\t}\r\n\t\t\tthis.pitch = Wad.pitches[pitch]\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif ( this.soundSource ) {\r\n\t\t\t\tthis.soundSource.frequency.value = pitch;\r\n\t\t\t}\r\n\t\t\tthis.pitch = pitch\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\tWad.prototype.setDetune = function(detune, timeConstant){\r\n\t\ttimeConstant = timeConstant || .01\r\n\t\tthis.soundSource.detune.setTargetAtTime(detune, context.currentTime, timeConstant)\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/** Change the panning of a Wad at any time, including during playback **/\r\n\tWad.prototype.setPanning = function(panning, timeConstant){\r\n\t\ttimeConstant = timeConstant || .01\r\n\t\tthis.panning.location = panning;\r\n\t\tif ( isArray(panning) && this.panning.type === '3d' && this.panning.node ) {\r\n\t\t\tthis.panning.node.setPosition(panning[0], panning[1], panning[2]);\r\n\r\n\t\t}\r\n\t\telse if ( typeof panning === 'number' && this.panning.type === 'stereo' && this.panning.node) {\r\n\t\t\tthis.panning.node.pan.setTargetAtTime(panning, context.currentTime, timeConstant)\r\n\t\t}\r\n\r\n\t\tif ( isArray(panning) ) { this.panning.type = '3d' }\r\n\t\telse if ( typeof panning === 'number' ) { this.panning.type = 'stereo' }\r\n\t\treturn this;\r\n\t};\r\n\r\n\t/**\r\n\tChange the Reverb of a Wad at any time, including during playback.\r\n\tinputWet is a value of 0 < wetness/gain < 1\r\n\t**/\r\n\tWad.prototype.setReverb = function(inputWet) {\r\n\r\n\t\t//Check/Save the input\r\n\r\n\t\tvar wet;\r\n\t\tif(inputWet && inputWet > 0 && inputWet < 1) wet = inputWet;\r\n\t\telse if(inputWet >= 1) wet = 1;\r\n\t\telse wet = 0;\r\n\r\n\t\t//Check if we have delay\r\n\t\tif(this.reverb) {\r\n\r\n\t\t\t//Set the value\r\n\t\t\tthis.reverb.wet = wet;\r\n\r\n\t\t\t//Set the node's value, if it exists\r\n\t\t\tif(this.reverb.node) {\r\n\r\n\t\t\t\tthis.reverb.node.wet.gain.value = wet;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t//Inform that there is no reverb on the current wad\r\n\t\t\tlogMessage(\"Sorry, but the wad does not contain Reverb!\");\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\r\n\t/**\r\n\tChange the Delay of a Wad at any time, including during playback.\r\n\tinputTime is a value of time > 0, and is the time in seconds between each delayed playback.\r\n\tinputWet is a value of gain 0 < inputWet < 1, and is Relative volume change between the original sound and the first delayed playback.\r\n\tinputFeedback is a value of gain 0 < inputFeedback < 1, and is Relative volume change between each delayed playback and the next.\r\n\t**/\r\n\tWad.prototype.setDelay = function(inputTime, inputWet, inputFeedback){\r\n\r\n\t\t//Check/Save the input\r\n\t\tvar time;\r\n\t\tif(inputTime && inputTime > 0) time = inputTime;\r\n\t\telse time = 0;\r\n\r\n\t\tvar wet;\r\n\t\tif(inputWet && inputWet > 0 && inputWet < 1) wet = inputWet;\r\n\t\telse if(inputWet >= 1) wet = 1;\r\n\t\telse wet = 0;\r\n\r\n\t\tvar feedback;\r\n\t\tif(inputFeedback && inputFeedback > 0 && inputFeedback < 1) feedback = inputFeedback;\r\n\t\telse if(inputFeedback >= 1) feedback = 1;\r\n\t\telse feedback = 0;\r\n\r\n\t\t//Check if we have delay\r\n\t\tif(this.delay) {\r\n\r\n\t\t\t//Set the value\r\n\t\t\tthis.delay.delayTime = time;\r\n\t\t\tthis.delay.wet = wet;\r\n\t\t\tthis.delay.feedback = feedback;\r\n\r\n\t\t\t//Set the node's value, if it exists\r\n\t\t\tif(this.delay.delayNode) {\r\n\r\n\t\t\t\tthis.delay.delayNode.delayNode.delayTime.value = time;\r\n\t\t\t\tthis.delay.delayNode.wetNode.gain.value = wet;\r\n\t\t\t\tthis.delay.delayNode.feedbackNode.gain.value = feedback;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t//Inform that there is no delay on the current wad\r\n\t\t\tlogMessage(\"Sorry, but the wad does not contain delay!\", 2);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t};\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\tWad.prototype.pause = function(label){\r\n\t\tthis.pauseTime = context.currentTime\r\n\t\tthis.stop(label)\r\n\t}\r\n\tWad.prototype.unpause = function(arg){\r\n\t\targ = arg || {}\r\n\t\tif ( this.pauseTime && this.lastPlayedTime ) {\r\n\t\t\targ.offset = this.pauseTime - this.lastPlayedTime\r\n\t\t}\r\n\t\telse { \r\n\t\t\tlogMessage(\"You tried to unpause a wad that was not played and paused, so it just played normally instead.\", 2)\r\n\t\t}\r\n\t\tthis.play(arg)\r\n\t}\r\n\r\n/** If multiple instances of a sound are playing simultaneously, stop() only can stop the most recent one **/\r\n\tWad.prototype.stop = function(label){\r\n\t\tif ( !( this.source === 'mic' ) ) {\r\n\t\t\tif ( !(this.gain && this.gain.length) ){\r\n\t\t\t\tlogMessage(\"You tried to stop a Wad that never played. \", 2)\r\n\t\t\t\tlogMessage(this, 2)\r\n\t\t\t\treturn // if the wad has never been played, there's no need to stop it\r\n\t\t\t}\r\n\t\t\telse if ( label ) {\r\n\t\t\t\tfor ( var i = 0; i < this.gain.length; i++ ) {\r\n\t\t\t\t\tif ( this.gain[i].label === label ) {\r\n\t\t\t\t\t\tthis.gain[i].gain.cancelScheduledValues(context.currentTime);\r\n\t\t\t\t\t\tthis.gain[i].gain.setValueAtTime(this.gain[i].gain.value, context.currentTime);\r\n\t\t\t\t\t\tthis.gain[i].gain.linearRampToValueAtTime(.0001, context.currentTime + this.env.release);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if ( !label ) {\r\n\t\t\t\tthis.gain[0].gain.cancelScheduledValues(context.currentTime);\r\n\t\t\t\tthis.gain[0].gain.setValueAtTime(this.gain[0].gain.value, context.currentTime);\r\n\t\t\t\tthis.gain[0].gain.linearRampToValueAtTime(.0001, context.currentTime + this.env.release);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (Wad.micConsent ) {\r\n\t\t\tthis.mediaStreamSource.disconnect(0);\r\n\t\t}\r\n\t\telse { logMessage('You have not given your browser permission to use your microphone.')}\r\n\t\tif ( this.tremolo ) {\r\n\t\t\tthis.tremolo.wad.stop()\r\n\t\t}\r\n\t};\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\tvar buflen = 2048;\r\n\tvar buf = new Uint8Array( buflen );\r\n\tvar MINVAL = 134;  // 128 == zero.  MINVAL is the \"minimum detected signal\" level.\r\n\r\n\tvar noteFromPitch = function( frequency ) {\r\n\t\tvar noteNum = 12 * (Math.log( frequency / 440 )/Math.log(2) );\r\n\t\treturn Math.round( noteNum ) + 69;\r\n\t}\r\n\r\n\tvar frequencyFromNoteNumber = function( note ) {\r\n\t\treturn 440 * Math.pow(2,(note-69)/12);\r\n\t}\r\n\r\n\tvar centsOffFromPitch = function( frequency, note ) {\r\n\t\treturn Math.floor( 1200 * Math.log( frequency / frequencyFromNoteNumber( note ))/Math.log(2) );\r\n\t}\r\n\r\n\r\n\tfunction autoCorrelate( buf, sampleRate ) {\r\n\t\tvar MIN_SAMPLES = 4;\t// corresponds to an 11kHz signal\r\n\t\tvar MAX_SAMPLES = 1000; // corresponds to a 44Hz signal\r\n\t\tvar SIZE = 1000;\r\n\t\tvar best_offset = -1;\r\n\t\tvar best_correlation = 0;\r\n\t\tvar rms = 0;\r\n\t\tvar foundGoodCorrelation = false;\r\n\r\n\t\tif (buf.length < (SIZE + MAX_SAMPLES - MIN_SAMPLES))\r\n\t\t\treturn -1;  // Not enough data\r\n\r\n\t\tfor ( var i = 0; i < SIZE; i++ ) {\r\n\t\t\tvar val = ( buf[i] - 128 ) / 128;\r\n\t\t\trms += val * val;\r\n\t\t}\r\n\t\trms = Math.sqrt(rms/SIZE);\r\n\t\tif (rms<0.01)\r\n\t\t\treturn -1;\r\n\r\n\t\tvar lastCorrelation=1;\r\n\t\tfor (var offset = MIN_SAMPLES; offset <= MAX_SAMPLES; offset++) {\r\n\t\t\tvar correlation = 0;\r\n\r\n\t\t\tfor (var i=0; i<SIZE; i++) {\r\n\t\t\t\tcorrelation += Math.abs(((buf[i] - 128)/128)-((buf[i+offset] - 128)/128));\r\n\t\t\t}\r\n\t\t\tcorrelation = 1 - (correlation/SIZE);\r\n\t\t\tif ((correlation>0.9) && (correlation > lastCorrelation))\r\n\t\t\t\tfoundGoodCorrelation = true;\r\n\t\t\telse if (foundGoodCorrelation) {\r\n\t\t\t\t// short-circuit - we found a good correlation, then a bad one, so we'd just be seeing copies from here.\r\n\t\t\t\treturn sampleRate/best_offset;\r\n\t\t\t}\r\n\t\t\tlastCorrelation = correlation;\r\n\t\t\tif (correlation > best_correlation) {\r\n\t\t\t\tbest_correlation = correlation;\r\n\t\t\t\tbest_offset = offset;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (best_correlation > 0.01) {\r\n\t\t\t// console.log(\"f = \" + sampleRate/best_offset + \"Hz (rms: \" + rms + \" confidence: \" + best_correlation + \")\")\r\n\t\t\treturn sampleRate/best_offset;\r\n\t\t}\r\n\t\treturn -1;\r\n\t//  var best_frequency = sampleRate/best_offset;\r\n\t}\r\n\r\n\r\n\tWad.Poly = function(arg){\r\n\t\tif ( !arg ) { arg = {}; }\r\n\t\tthis.isSetUp  = false;\r\n\t\tthis.playable = 1;\r\n\r\n\t\tif ( arg.reverb ) {\r\n\t\t\tconstructReverb(this, arg); // We need to make sure we have downloaded the impulse response before continuing with the setup.\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.setUp(arg);\r\n\t\t}\r\n\t};\r\n\r\n\tWad.Poly.prototype.setUp = function(arg){ // Anything that needs to happen before reverb is set up can go here.\r\n\t\tthis.wads\t\t\t  = [];\r\n\t\tthis.input\t\t\t = context.createAnalyser();\r\n\t\tthis.input.fftSize\t = 2048\r\n\t\tthis.nodes\t\t\t = [this.input];\r\n\t\tthis.destination\t   = arg.destination || context.destination; // the last node the sound is routed to\r\n\t\tthis.volume\t\t\t= arg.volume || 1;\r\n\t\tthis.gain\t\t\t  = context.createGain();\r\n\t\tthis.gain.gain.value   = this.volume;\r\n\t\tthis.output\t\t\t= context.createAnalyser();\r\n\t\tthis.tuna\t\t\t  = arg.tuna || null;\r\n\r\n\t\tthis.globalReverb = arg.globalReverb || false; // deprecated\r\n\r\n\t\tconstructFilter(this, arg);\r\n\t\tif ( this.filter ) { createFilters(this, arg); }\r\n\r\n\t\tif ( this.reverb ) { setUpReverbOnPlay(this, arg); }\r\n\r\n\t\tthis.constructExternalFx(arg, context);\r\n\r\n\t\tconstructPanning(this, arg);\r\n\t\tsetUpPanningOnPlay(this, arg);\r\n\t\tif ( arg.compressor ) { constructCompressor(this, arg); }\r\n\r\n\t\tconstructDelay(this, arg);\r\n\t\tsetUpDelayOnPlay(this, arg);\r\n\t\tsetUpTunaOnPlay(this, arg);\r\n\t\tthis.nodes.push(this.gain);\r\n\t\tthis.nodes.push(this.output);\r\n\t\tplugEmIn(this, arg);\r\n\t\tthis.isSetUp = true;\r\n\t\tif ( arg.callback ) { arg.callback(this); }\r\n\t}\r\n\r\n\tWad.SoundIterator = function(args){\r\n\t\treturn new SoundIterator(args, Wad)\r\n\t}\r\n\r\n/**\r\n\tThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 Chris Wilson\r\n**/\r\n\tWad.Poly.prototype.updatePitch = function( time ) {\r\n\t\tthis.input.getByteTimeDomainData( buf );\r\n\t\tvar ac = autoCorrelate( buf, context.sampleRate );\r\n\r\n\t\tif ( ac !== -1 && ac !== 11025 && ac !== 12000 ) {\r\n\t\t\tvar pitch = ac;\r\n\t\t\tthis.pitch = Math.floor( pitch ) ;\r\n\t\t\tvar note = noteFromPitch( pitch );\r\n\t\t\tthis.noteName = Wad.pitchesArray[note - 12];\r\n\t\t\t// Detune doesn't seem to work.\r\n\t\t\t// var detune = centsOffFromPitch( pitch, note );\r\n\t\t\t// if (detune == 0 ) {\r\n\t\t\t//\t this.detuneEstimate = 0;\r\n\t\t\t// } else {\r\n\r\n\t\t\t//\t this.detuneEstimate = detune\r\n\t\t\t// }\r\n\t\t}\r\n\t\tvar that = this;\r\n\t\tthat.rafID = window.requestAnimationFrame( function(){ that.updatePitch() } );\r\n\t}\r\n\r\n\tWad.Poly.prototype.stopUpdatingPitch = function(){\r\n\t\tcancelAnimationFrame(this.rafID)\r\n\t}\r\n\r\n\tWad.Poly.prototype.setVolume = function(volume){\r\n\t\tif ( this.isSetUp ) {\r\n\t\t\tthis.gain.gain.value = volume;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlogMessage('This PolyWad is not set up yet.');\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tWad.Poly.prototype.setPitch = function(pitch){\r\n\t\tthis.wads.forEach(function(wad){\r\n\t\t\t\r\n\t\t\tif ( pitch in Wad.pitches ) {\r\n\t\t\t\tif ( wad.soundSource ) {\r\n\t\t\t\t\twad.soundSource.frequency.value = Wad.pitches[pitch];\r\n\t\t\t\t}\r\n\t\t\t\twad.pitch = Wad.pitches[pitch]\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif ( wad.soundSource ) {\r\n\t\t\t\t\twad.soundSource.frequency.value = pitch;\r\n\t\t\t\t}\r\n\t\t\t\twad.pitch = pitch\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t})\r\n\t}\r\n\r\n\tWad.Poly.prototype.play = function(arg){\r\n\t\tif ( this.isSetUp ) {\r\n\t\t\tif ( this.playable < 1 ) {\r\n\t\t\t\tthis.playOnLoad\t= true;\r\n\t\t\t\tthis.playOnLoadArg = arg;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif ( arg && arg.volume ) {\r\n\t\t\t\t\tthis.gain.gain.value = arg.volume; // if two notes are played with volume set as a play arg, does the second one overwrite the first? maybe input should be an array of gain nodes, like regular wads.\r\n\t\t\t\t\targ.volume = undefined; // if volume is set, it should change the gain on the polywad's gain node, NOT the gain nodes for individual wads inside the polywad.\r\n\t\t\t\t}\r\n\t\t\t\tfor ( var i = 0; i < this.wads.length; i++ ) {\r\n\t\t\t\t\tthis.wads[i].play(arg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlogMessage('This PolyWad is not set up yet.');\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\tWad.Poly.prototype.stop = function(arg){\r\n\t\tif ( this.isSetUp ) {\r\n\t\t\tfor ( var i = 0; i < this.wads.length; i++ ) {\r\n\t\t\t\tthis.wads[i].stop(arg);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tWad.Poly.prototype.add = function(wad){\r\n\t\tif ( this.isSetUp ) {\r\n\t\t\twad.destination = this.input;\r\n\t\t\tthis.wads.push(wad);\r\n\t\t\tif ( wad instanceof Wad.Poly ) {\r\n\t\t\t\twad.output.disconnect(0);\r\n\t\t\t\twad.output.connect(this.input);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlogMessage('This PolyWad is not set up yet.');\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\r\n\r\n\tWad.Poly.prototype.remove = function(wad){\r\n\t\tif ( this.isSetUp ) {\r\n\t\t\tfor ( var i = 0; i < this.wads.length; i++ ) {\r\n\t\t\t\tif ( this.wads[i] === wad ) {\r\n\t\t\t\t\tthis.wads[i].destination = context.destination;\r\n\t\t\t\t\tthis.wads.splice(i,1);\r\n\t\t\t\t\tif ( wad instanceof Wad.Poly ) {\r\n\t\t\t\t\t\twad.output.disconnect(0);\r\n\t\t\t\t\t\twad.output.connect(context.destination);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t};\r\n\r\n\tWad.Poly.prototype.constructExternalFx = function(arg, context){\r\n\r\n\t};\r\n\r\n\tWad.stopAll = function(label){\r\n\t\tfor ( var i = 0; i < Wad.allWads.length; i++ ) {\r\n\t\t\tWad.allWads[i].stop(label)\r\n\t\t}\r\n\t}\r\n\tWad.setVolume = function(volume){\r\n\t\tfor ( var i = 0; i < Wad.allWads.length; i++ ) {\r\n\t\t\tWad.allWads[i].setVolume(volume)\r\n\t\t}\r\n\t}\r\n\r\n/** If a Wad is created with reverb without specifying a URL for the impulse response,\r\ngrab it from the defaultImpulse URL **/\r\n\tWad.defaultImpulse = 'https://www.codecur.io/audio/widehall.wav';\r\n\r\n\t// This method is deprecated.\r\n\tWad.setGlobalReverb = function(arg){\r\n\t\tWad.reverb\t\t\t\t = {};\r\n\t\tWad.reverb.node\t\t\t= context.createConvolver();\r\n\t\tWad.reverb.gain\t\t\t= context.createGain();\r\n\t\tWad.reverb.gain.gain.value = arg.wet;\r\n\t\tvar impulseURL\t\t\t = arg.impulse || Wad.defaultImpulse;\r\n\t\tvar request\t\t\t\t= new XMLHttpRequest();\r\n\t\trequest.open(\"GET\", impulseURL, true);\r\n\t\trequest.responseType = \"arraybuffer\";\r\n\r\n\t\trequest.onload = function() {\r\n\t\t\tcontext.decodeAudioData(request.response, function (decodedBuffer){\r\n\t\t\t\tWad.reverb.node.buffer = decodedBuffer;\r\n\t\t\t});\r\n\t\t};\r\n\t\trequest.send();\r\n\r\n\t};\r\n//////////////////////////////////////////////////////////////////////////////////////\r\n//  Utility function to avoid javascript type conversion bug checking zero values   //\r\n\r\n\tvar valueOrDefault = function(value, def) {\r\n\t\tvar val = (value == null) ? def : value;\r\n\t\treturn val;\r\n\t};\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////\r\n/** This object is a mapping of note names to frequencies. **/\r\n\tWad.pitches = {\r\n\t\t'A0'  : 27.5000,\r\n\t\t'A#0' : 29.1352,\r\n\t\t'Bb0' : 29.1352,\r\n\t\t'B0'  : 30.8677,\r\n\t\t'B#0' : 32.7032,\r\n\t\t'Cb1' : 30.8677,\r\n\t\t'C1'  : 32.7032,\r\n\t\t'C#1' : 34.6478,\r\n\t\t'Db1' : 34.6478,\r\n\t\t'D1'  : 36.7081,\r\n\t\t'D#1' : 38.8909,\r\n\t\t'Eb1' : 38.8909,\r\n\t\t'E1'  : 41.2034,\r\n\t\t'Fb1' : 41.2034,\r\n\t\t'E#1' : 43.6535,\r\n\t\t'F1'  : 43.6535,\r\n\t\t'F#1' : 46.2493,\r\n\t\t'Gb1' : 46.2493,\r\n\t\t'G1'  : 48.9994,\r\n\t\t'G#1' : 51.9131,\r\n\t\t'Ab1' : 51.9131,\r\n\t\t'A1'  : 55.0000,\r\n\t\t'A#1' : 58.2705,\r\n\t\t'Bb1' : 58.2705,\r\n\t\t'B1'  : 61.7354,\r\n\t\t'Cb2' : 61.7354,\r\n\t\t'B#1' : 65.4064,\r\n\t\t'C2'  : 65.4064,\r\n\t\t'C#2' : 69.2957,\r\n\t\t'Db2' : 69.2957,\r\n\t\t'D2'  : 73.4162,\r\n\t\t'D#2' : 77.7817,\r\n\t\t'Eb2' : 77.7817,\r\n\t\t'E2'  : 82.4069,\r\n\t\t'Fb2' : 82.4069,\r\n\t\t'E#2' : 87.3071,\r\n\t\t'F2'  : 87.3071,\r\n\t\t'F#2' : 92.4986,\r\n\t\t'Gb2' : 92.4986,\r\n\t\t'G2'  : 97.9989,\r\n\t\t'G#2' : 103.826,\r\n\t\t'Ab2' : 103.826,\r\n\t\t'A2'  : 110.000,\r\n\t\t'A#2' : 116.541,\r\n\t\t'Bb2' : 116.541,\r\n\t\t'B2'  : 123.471,\r\n\t\t'Cb3' : 123.471,\r\n\t\t'B#2' : 130.813,\r\n\t\t'C3'  : 130.813,\r\n\t\t'C#3' : 138.591,\r\n\t\t'Db3' : 138.591,\r\n\t\t'D3'  : 146.832,\r\n\t\t'D#3' : 155.563,\r\n\t\t'Eb3' : 155.563,\r\n\t\t'E3'  : 164.814,\r\n\t\t'Fb3' : 164.814,\r\n\t\t'E#3' : 174.614,\r\n\t\t'F3'  : 174.614,\r\n\t\t'F#3' : 184.997,\r\n\t\t'Gb3' : 184.997,\r\n\t\t'G3'  : 195.998,\r\n\t\t'G#3' : 207.652,\r\n\t\t'Ab3' : 207.652,\r\n\t\t'A3'  : 220.000,\r\n\t\t'A#3' : 233.082,\r\n\t\t'Bb3' : 233.082,\r\n\t\t'B3'  : 246.942,\r\n\t\t'Cb4' : 246.942,\r\n\t\t'B#3' : 261.626,\r\n\t\t'C4'  : 261.626,\r\n\t\t'C#4' : 277.183,\r\n\t\t'Db4' : 277.183,\r\n\t\t'D4'  : 293.665,\r\n\t\t'D#4' : 311.127,\r\n\t\t'Eb4' : 311.127,\r\n\t\t'E4'  : 329.628,\r\n\t\t'Fb4' : 329.628,\r\n\t\t'E#4' : 349.228,\r\n\t\t'F4'  : 349.228,\r\n\t\t'F#4' : 369.994,\r\n\t\t'Gb4' : 369.994,\r\n\t\t'G4'  : 391.995,\r\n\t\t'G#4' : 415.305,\r\n\t\t'Ab4' : 415.305,\r\n\t\t'A4'  : 440.000,\r\n\t\t'A#4' : 466.164,\r\n\t\t'Bb4' : 466.164,\r\n\t\t'B4'  : 493.883,\r\n\t\t'Cb5' : 493.883,\r\n\t\t'B#4' : 523.251,\r\n\t\t'C5'  : 523.251,\r\n\t\t'C#5' : 554.365,\r\n\t\t'Db5' : 554.365,\r\n\t\t'D5'  : 587.330,\r\n\t\t'D#5' : 622.254,\r\n\t\t'Eb5' : 622.254,\r\n\t\t'E5'  : 659.255,\r\n\t\t'Fb5' : 659.255,\r\n\t\t'E#5' : 698.456,\r\n\t\t'F5'  : 698.456,\r\n\t\t'F#5' : 739.989,\r\n\t\t'Gb5' : 739.989,\r\n\t\t'G5'  : 783.991,\r\n\t\t'G#5' : 830.609,\r\n\t\t'Ab5' : 830.609,\r\n\t\t'A5'  : 880.000,\r\n\t\t'A#5' : 932.328,\r\n\t\t'Bb5' : 932.328,\r\n\t\t'B5'  : 987.767,\r\n\t\t'Cb6' : 987.767,\r\n\t\t'B#5' : 1046.50,\r\n\t\t'C6'  : 1046.50,\r\n\t\t'C#6' : 1108.73,\r\n\t\t'Db6' : 1108.73,\r\n\t\t'D6'  : 1174.66,\r\n\t\t'D#6' : 1244.51,\r\n\t\t'Eb6' : 1244.51,\r\n\t\t'Fb6' : 1318.51,\r\n\t\t'E6'  : 1318.51,\r\n\t\t'E#6' : 1396.91,\r\n\t\t'F6'  : 1396.91,\r\n\t\t'F#6' : 1479.98,\r\n\t\t'Gb6' : 1479.98,\r\n\t\t'G6'  : 1567.98,\r\n\t\t'G#6' : 1661.22,\r\n\t\t'Ab6' : 1661.22,\r\n\t\t'A6'  : 1760.00,\r\n\t\t'A#6' : 1864.66,\r\n\t\t'Bb6' : 1864.66,\r\n\t\t'B6'  : 1975.53,\r\n\t\t'Cb7' : 1975.53,\r\n\t\t'B#6' : 2093.00,\r\n\t\t'C7'  : 2093.00,\r\n\t\t'C#7' : 2217.46,\r\n\t\t'Db7' : 2217.46,\r\n\t\t'D7'  : 2349.32,\r\n\t\t'D#7' : 2489.02,\r\n\t\t'Eb7' : 2489.02,\r\n\t\t'E7'  : 2637.02,\r\n\t\t'Fb7' : 2637.02,\r\n\t\t'E#7' : 2793.83,\r\n\t\t'F7'  : 2793.83,\r\n\t\t'F#7' : 2959.96,\r\n\t\t'Gb7' : 2959.96,\r\n\t\t'G7'  : 3135.96,\r\n\t\t'G#7' : 3322.44,\r\n\t\t'Ab7' : 3322.44,\r\n\t\t'A7'  : 3520.00,\r\n\t\t'A#7' : 3729.31,\r\n\t\t'Bb7' : 3729.31,\r\n\t\t'B7'  : 3951.07,\r\n\t\t'Cb8' : 3951.07,\r\n\t\t'B#7' : 4186.01,\r\n\t\t'C8'  : 4186.01\r\n\t};\r\n\r\n\r\n\tWad.pitchesArray = [ // Just an array of note names. This can be useful for mapping MIDI data to notes.\r\n\t\t'C0',\r\n\t\t'C#0',\r\n\t\t'D0',\r\n\t\t'D#0',\r\n\t\t'E0',\r\n\t\t'F0',\r\n\t\t'F#0',\r\n\t\t'G0',\r\n\t\t'G#0',\r\n\t\t'A0',\r\n\t\t'A#0',\r\n\t\t'B0',\r\n\t\t'C1',\r\n\t\t'C#1',\r\n\t\t'D1',\r\n\t\t'D#1',\r\n\t\t'E1',\r\n\t\t'F1',\r\n\t\t'F#1',\r\n\t\t'G1',\r\n\t\t'G#1',\r\n\t\t'A1',\r\n\t\t'A#1',\r\n\t\t'B1',\r\n\t\t'C2',\r\n\t\t'C#2',\r\n\t\t'D2',\r\n\t\t'D#2',\r\n\t\t'E2',\r\n\t\t'F2',\r\n\t\t'F#2',\r\n\t\t'G2',\r\n\t\t'G#2',\r\n\t\t'A2',\r\n\t\t'A#2',\r\n\t\t'B2',\r\n\t\t'C3',\r\n\t\t'C#3',\r\n\t\t'D3',\r\n\t\t'D#3',\r\n\t\t'E3',\r\n\t\t'F3',\r\n\t\t'F#3',\r\n\t\t'G3',\r\n\t\t'G#3',\r\n\t\t'A3',\r\n\t\t'A#3',\r\n\t\t'B3',\r\n\t\t'C4',\r\n\t\t'C#4',\r\n\t\t'D4',\r\n\t\t'D#4',\r\n\t\t'E4',\r\n\t\t'F4',\r\n\t\t'F#4',\r\n\t\t'G4',\r\n\t\t'G#4',\r\n\t\t'A4',\r\n\t\t'A#4',\r\n\t\t'B4',\r\n\t\t'C5',\r\n\t\t'C#5',\r\n\t\t'D5',\r\n\t\t'D#5',\r\n\t\t'E5',\r\n\t\t'F5',\r\n\t\t'F#5',\r\n\t\t'G5',\r\n\t\t'G#5',\r\n\t\t'A5',\r\n\t\t'A#5',\r\n\t\t'B5',\r\n\t\t'C6',\r\n\t\t'C#6',\r\n\t\t'D6',\r\n\t\t'D#6',\r\n\t\t'E6',\r\n\t\t'F6',\r\n\t\t'F#6',\r\n\t\t'G6',\r\n\t\t'G#6',\r\n\t\t'A6',\r\n\t\t'A#6',\r\n\t\t'B6',\r\n\t\t'C7',\r\n\t\t'C#7',\r\n\t\t'D7',\r\n\t\t'D#7',\r\n\t\t'E7',\r\n\t\t'F7',\r\n\t\t'F#7',\r\n\t\t'G7',\r\n\t\t'G#7',\r\n\t\t'A7',\r\n\t\t'A#7',\r\n\t\t'B7',\r\n\t\t'C8'\r\n\t];\r\n//////////////////////////////////////////////////////////////\r\n\tWad.assignMidiMap = function(midiMap, which, success, failure){\r\n\t\tvar which = which || 0;\r\n\t\tnavigator.requestMIDIAccess().then(function(){\r\n\t\t\tif ( Wad.midiInputs[which] ) {\r\n\t\t\t\tWad.midiInputs[which].onmidimessage = midiMap;\r\n\t\t\t\tif  ( typeof success === 'function' ) { success() }\r\n\t\t\t}\r\n\t\t\telse if ( typeof failure === 'function' ) { failure() }\r\n\r\n\t\t})\r\n\r\n\t}\r\n\tWad.midiInstrument = {\r\n\t\tplay : function() { logMessage('playing midi')  },\r\n\t\tstop : function() { logMessage('stopping midi') }\r\n\t};\r\n\tWad.midiInputs  = [];\r\n\r\n\tvar midiMap = function(event){\r\n\t\tlogMessage(event.receivedTime, event.data, 2);\r\n\t\tif ( event.data[0] === 144 ) { // 144 means the midi message has note data\r\n\t\t\tif ( event.data[2] === 0 ) { // noteOn velocity of 0 means this is actually a noteOff message\r\n\t\t\t\tlogMessage(\"Playing note: \", 2)\r\n\t\t\t\tlogMessage(Wad.pitchesArray[event.data[1]-12], 2);\r\n\t\t\t\tWad.midiInstrument.stop(Wad.pitchesArray[event.data[1]-12]);\r\n\t\t\t}\r\n\t\t\telse if ( event.data[2] > 0 ) {\r\n\t\t\t\tlogMessage(\"Stopping note: \", 2)\r\n\t\t\t\tlogMessage(Wad.pitchesArray[event.data[1]-12], 2);\r\n\t\t\t\tWad.midiInstrument.play({pitch : Wad.pitchesArray[event.data[1]-12], label : Wad.pitchesArray[event.data[1]-12], callback : function(that){\r\n\t\t\t\t}})\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ( event.data[0] === 176 ) { // 176 means the midi message has controller data\r\n\t\t\tlogMessage('controller');\r\n\t\t\tif ( event.data[1] == 46 ) {\r\n\t\t\t\tif ( event.data[2] == 127 ) { Wad.midiInstrument.pedalMod = true; }\r\n\t\t\t\telse if ( event.data[2] == 0 ) { Wad.midiInstrument.pedalMod = false; }\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ( event.data[0] === 224 ) { // 224 means the midi message has pitch bend data\r\n\t\t\tlogMessage('pitch bend');\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tvar onSuccessCallback = function(midiAccess){\r\n\r\n\t\tWad.midiInputs = []\r\n\t\tvar val = midiAccess.inputs.values();\r\n\t\tfor ( var o = val.next(); !o.done; o = val.next() ) {\r\n\t\t\tWad.midiInputs.push(o.value)\r\n\t\t}\r\n\t\t// Wad.midiInputs = [m.inputs.values().next().value];   // inputs = array of MIDIPorts\r\n\t\tlogMessage('MIDI inputs: ')\r\n\t\tlogMessage(Wad.midiInputs)\r\n\t\t// var outputs = m.outputs(); // outputs = array of MIDIPorts\r\n\t\tfor ( var i = 0; i < Wad.midiInputs.length; i++ ) {\r\n\t\t\tWad.midiInputs[i].onmidimessage = midiMap; // onmidimessage( event ), event.data & event.receivedTime are populated\r\n\t\t}\r\n\t\t// var o = m.outputs()[0];\t\t   // grab first output device\r\n\t\t// o.send( [ 0x90, 0x45, 0x7f ] );\t // full velocity note on A4 on channel zero\r\n\t\t// o.send( [ 0x80, 0x45, 0x7f ], window.performance.now() + 1000 );  // full velocity A4 note off in one second.\r\n\t};\r\n\tvar onErrorCallback = function(err){\r\n\t\tlogMessage(\"Failed to get MIDI access\", err);\r\n\t};\r\n\r\n\tif ( navigator && navigator.requestMIDIAccess ) {\r\n\t\ttry {\r\n\t\t\tnavigator.requestMIDIAccess().then(onSuccessCallback, onErrorCallback);\r\n\t\t}\r\n\t\tcatch(err) {\r\n\t\t\tlogMessage(\"Failed to get MIDI access\", err);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tWad.presets = {\r\n\t\thiHatClosed : { source : 'noise', env : { attack : .001, decay : .008, sustain : .2, hold : .03, release : .01}, filter : { type : 'highpass', frequency : 400, q : 1 } },\r\n\t\tsnare : { source : 'noise', env : {attack : .001, decay : .01, sustain : .2, hold : .03, release : .02}, filter : {type : 'bandpass', frequency : 300, q : .180 } },\r\n\t\thiHatOpen : { source : 'noise', env : { attack : .001, decay : .008, sustain : .2, hold : .43, release : .01}, filter : { type : 'highpass', frequency : 100, q : .2 } },\r\n\t\tghost : { source : 'square', volume : .3, env : { attack : .01, decay : .002, sustain : .5, hold : 2.5, release : .3 }, filter : { type : 'lowpass', frequency : 600, q : 7, env : { attack : .7, frequency : 1600 } }, vibrato : { attack : 8, speed : 8, magnitude : 100 } },\r\n\t\tpiano : { source : 'square', volume : 1.4, env : { attack : .01, decay : .005, sustain : .2, hold : .015, release : .3 }, filter : { type : 'lowpass', frequency : 1200, q : 8.5, env : { attack : .2, frequency : 600 } } }\r\n\t};\r\n\r\n\tWad.logs = logStuff\r\n\r\n\treturn Wad;\r\n\r\n\r\n})()\r\n\r\nif(typeof module !== 'undefined' && module.exports) {\r\n\tmodule.exports = Wad;\r\n}\r\n\r\nexport default Wad;\r\n\r\n"],"sourceRoot":""}